<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <link href="/libs/katex/katex.min.css" rel="stylesheet" />
    <link href="/css/katex.css" rel="stylesheet" />
    <link
      href="/libs/highlight/styles/atom-one-light.min.css"
      rel="stylesheet"
    />
    <link href="/css/highlight.css" rel="stylesheet" />
    <link href="/css/main.css" rel="stylesheet" />
    <link href="/assets/favicon.svg" rel="icon" />
    <title>Algorithms for competitive programming</title>
    <meta
      content="Implementations of some useful algorithms."
      name="description"
    />
  </head>
  <body>
    <header>
      <div class="blog-name">
        <a href="/"><b class="font-weight-bold">Stephen</b> Huan</a>
      </div>
      <nav>
        <ul>
          <li><a class="" href="/">about</a></li>
          <li><a class="active" href="/blog/">blog</a></li>
          <li><a class="" href="/projects/">projects</a></li>
          <li><a class="" href="/publications/">publications</a></li>
          <li><a class="" href="/assets/pdf/cv.pdf">cv</a></li>
        </ul>
        <img
          alt="menu icon"
          height="32"
          id="menu-icon"
          src="/assets/hamburger.svg"
          width="32"
        />
      </nav>
    </header>
    <!-- Content appended here -->
    <div class="franklin-content">
      <h1>Algorithms for competitive programming</h1>
      <span class="post-meta"
        ><time datetime="2019-12-07">2019-12-07</time></span
      ><span class="post-tags"
        >  ·  <a href="/tag/cs/"><b>#</b> cs</a></span
      >
      <div class="franklin-toc">
        <ol>
          <li>
            <a href="#basics">Basics</a>
            <ol>
              <li><a href="#input">Input</a></li>
            </ol>
          </li>
          <li>
            <a href="#numerical_algorithms">Numerical Algorithms</a>
            <ol>
              <li><a href="#number_theory">Number Theory</a></li>
              <li><a href="#binary">Binary</a></li>
              <li><a href="#matrices">Matrices</a></li>
              <li><a href="#linear_programming">Linear Programming</a></li>
              <li>
                <a href="#fast_fourier_transform">Fast Fourier Transform</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#strings">Strings</a>
            <ol>
              <li><a href="#suffix_structures">Suffix Structures</a></li>
              <li><a href="#matching">Matching</a></li>
            </ol>
          </li>
          <li>
            <a href="#dynamic_programming">Dynamic Programming</a>
            <ol>
              <li><a href="#memoization">Memoization</a></li>
            </ol>
          </li>
          <li>
            <a href="#graph_algorithms">Graph Algorithms</a>
            <ol>
              <li><a href="#traversals">Traversals</a></li>
              <li><a href="#shortest_path">Shortest Path</a></li>
              <li><a href="#union-find">Union-find</a></li>
              <li>
                <a href="#minimum_spanning_tree">Minimum Spanning Tree</a>
              </li>
              <li><a href="#connected_components">Connected Components</a></li>
              <li><a href="#tree">Tree</a></li>
              <li><a href="#flow">Flow</a></li>
            </ol>
          </li>
          <li><a href="#sorting">Sorting</a></li>
          <li>
            <a href="#data_structures">Data Structures</a>
            <ol>
              <li><a href="#monotonic_query">Monotonic Query</a></li>
              <li><a href="#range_minimum_query">Range Minimum Query</a></li>
              <li><a href="#trees">Trees</a></li>
              <li><a href="#prefix_sums">Prefix Sums</a></li>
            </ol>
          </li>
          <li>
            <a href="#computational_geometry">Computational Geometry</a>
            <ol>
              <li><a href="#closest_pair">Closest Pair</a></li>
              <li><a href="#convex_hull">Convex Hull</a></li>
            </ol>
          </li>
          <li>
            <a href="#ad-hoc">Ad-hoc</a>
            <ol>
              <li><a href="#grid_bfs_problems">Grid BFS Problems</a></li>
            </ol>
          </li>
        </ol>
      </div>
      <h2 id="basics"><a class="header-anchor" href="#basics">Basics</a></h2>
      <p>Running: <code>python</code>.</p>
      <p>Profiling: <code>python -m cProfile -s tottime</code>.</p>
      <p>
        Fast execution: <a href="https://www.pypy.org/"><code>pypy</code></a
        >.
      </p>
      <h3 id="input"><a class="header-anchor" href="#input">Input</a></h3>
      <h4 id="usaco"><a class="header-anchor" href="#usaco">USACO</a></h4>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span>: sys.stdin.readline()[:-<span class="hljs-number">1</span>] <span class="hljs-comment"># fast cin</span>

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"test.in"</span>) <span class="hljs-keyword">as</span> f:
    N = <span class="hljs-built_in">int</span>(f.readline())
    N, M = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split())
    l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split()))
    m = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line.split())) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"test.out"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:
    f.write(<span class="hljs-built_in">str</span>(ans) + <span class="hljs-string">"\n"</span>)</code></pre>
      <h4 id="fast_inputoutput">
        <a class="header-anchor" href="#fast_inputoutput">Fast input/output</a>
      </h4>
      <p>
        <a href="https://www.spoj.com/problems/INTEST/"
          >Verification: SPOJ INTEST</a
        >, <a href="https://www.spoj.com/problems/INOUTEST/">SPOJ INOUTEST</a>,
        testing with
        <a href="https://docs.python.org/3/library/timeit.html">timeit</a>
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = sys.stdin.readline <span class="hljs-comment"># fast cin</span>

__lines, __<span class="hljs-built_in">print</span> = [], <span class="hljs-built_in">print</span>
<span class="hljs-built_in">print</span> = <span class="hljs-keyword">lambda</span> s: __lines.append(s) <span class="hljs-comment"># fast cout</span>
cout = <span class="hljs-keyword">lambda</span>: __<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, __lines)))</code></pre>
      <h4 id="codeforces">
        <a class="header-anchor" href="#codeforces">Codeforces</a>
      </h4>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = sys.stdin.readline <span class="hljs-comment"># fast cin</span>

N = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())
l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))</code></pre>
      <h4 id="graphs"><a class="header-anchor" href="#graphs">Graphs</a></h4>
      <h5 id="unweighted">
        <a class="header-anchor" href="#unweighted">Unweighted</a>
      </h5>
      <pre><code class="python hljs">graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x) - <span class="hljs-number">1</span>, f.readline().split())
    graph[a].append(b)
    graph[b].append(a)</code></pre>
      <h5 id="weighted">
        <a class="header-anchor" href="#weighted">Weighted</a>
      </h5>
      <pre><code class="python hljs">graph = {i: {} <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split())
    a -= <span class="hljs-number">1</span>
    b -= <span class="hljs-number">1</span>
    <span class="hljs-comment"># will overwrite if same edge is repeated - pick min edge (usually)</span>
    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph[a] <span class="hljs-keyword">or</span> w &lt; graph[a][b]:
        graph[a][b] = w
    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph[b] <span class="hljs-keyword">or</span> w &lt; graph[b][a]:
        graph[b][a] = w</code></pre>
      <h2 id="numerical_algorithms">
        <a class="header-anchor" href="#numerical_algorithms"
          >Numerical Algorithms</a
        >
      </h2>
      <h3 id="number_theory">
        <a class="header-anchor" href="#number_theory">Number Theory</a>
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm"
          >Euclidean algorithm</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>b</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log b)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">b</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>:
        a, b = b, a % b
    <span class="hljs-keyword">return</span> a

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>: <span class="hljs-keyword">return</span> (a//gcd(a, b))*b</code></pre>
      <p>floor</p>
      <pre><code class="python hljs">x//<span class="hljs-number">1</span></code></pre>
      <p>ceiling</p>
      <pre><code class="python hljs">-(-x//<span class="hljs-number">1</span>)</code></pre>
      <h4 id="primes"><a class="header-anchor" href="#primes">Primes</a></h4>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prime</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">""" Checks whether a number is prime or not with trial divison. """</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n != <span class="hljs-number">2</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):
        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"
          >Sieve of Eratosthenes</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/G"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sieve</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Generates a look up table of primality up to n. """</span>
    l = [<span class="hljs-literal">True</span>]*(n + <span class="hljs-number">1</span>)
    l[<span class="hljs-number">0</span>] = l[<span class="hljs-number">1</span>] = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> l[i]:
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i*i, <span class="hljs-built_in">len</span>(l), i):
                l[j] = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> l</code></pre>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">primes</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Return a list of all primes less than or equal to n. """</span>
    s = sieve(n)
    <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> s[i]]</code></pre>
      <h4 id="modulo"><a class="header-anchor" href="#modulo">Modulo</a></h4>
      <pre><code class="python hljs"><span class="hljs-comment"># common</span>
m = <span class="hljs-number">1000000007</span>

(a + b) % m == ((a % m) + (b % m)) % m
(a - b) % m == ((a % m) - (b % m)) % m
(a * b) % m == ((a % m) * (b % m)) % m</code></pre>
      <p>
        tl;dr spam modulo if the problem asks you to return the answer mod
        <code>m</code>.
      </p>
      <p>
        If asking for count (which is often) must be
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mo>≥</mo><mn>0</mn></mrow
                ><annotation encoding="application/x-tex">
                  \geq 0
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-026f25c021cbeaef"></span
              ><span class="mrel">≥</span
              ><span class="mspace katex-b9d9edcedd93f43c"></span></span
            ><span class="base"
              ><span class="strut katex-425d6a7bf437e87c"></span
              ><span class="mord">0</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs">x <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x + m</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Modular_exponentiation"
          >Modular exponentiation</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/E"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>e</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log e)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">e</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mod_exp</span>(<span class="hljs-params">b: <span class="hljs-built_in">int</span>, e: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns b^e % m """</span>
    <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    rtn = <span class="hljs-number">1</span>
    b %= m
    <span class="hljs-keyword">while</span> e &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># bit on in the binary representation of the exponent</span>
        <span class="hljs-keyword">if</span> e &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            rtn = (rtn*b) % m
        e &gt;&gt;= <span class="hljs-number">1</span>
        b = (b*b) % m
    <span class="hljs-keyword">return</span> rtn</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"
          >Extended Euclidean algorithm</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/G"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>b</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log b)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">b</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extended_gcd</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Returns (gcd(a, b), x, y) such that ax + by = gcd(a, b). """</span>
    x, xp = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    y, yp = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
    r, rp = b, a

    <span class="hljs-keyword">while</span> r != <span class="hljs-number">0</span>:
        q = rp//r
        rp, r = r, rp - q*r
        xp, x = x, xp - q*x
        yp, y = y, yp - q*y

    <span class="hljs-keyword">return</span> rp, xp, yp</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse"
          >Modular multiplicative inverse</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/G"
          >Verification</a
        >
        - Complexity: same as the Euclidean algorithm
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the inverse y such that xy mod m = 1. """</span>
    <span class="hljs-keyword">return</span> extended_gcd(x, m)[<span class="hljs-number">1</span>] % m

(a/b) % m == (a*inv(b, m)) % m</code></pre>
      <h4 id="factorization">
        <a class="header-anchor" href="#factorization">Factorization</a>
      </h4>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factor</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Factors a number with trial division. """</span>
    l = {<span class="hljs-number">1</span>, n}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:
            l.add(i)
            l.add(n//i)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(l)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Trial_division"
          >Prime Factorization</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/G"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><msqrt><mi>x</mi></msqrt
                  ><mi mathvariant="normal">/</mi><mi>log</mi><mo>⁡</mo
                  ><mi>x</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\sqrt{x}/\log{x})
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-530e7020c0aff428"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord sqrt"
                ><span class="vlist-t vlist-t2"
                  ><span class="vlist-r"
                    ><span class="vlist katex-732cda3eb34030b0"
                      ><span class="svg-align katex-48bfdc4f0cc83b58"
                        ><span class="pstrut katex-3ac4c1d77ccd6fb1"></span
                        ><span class="mord katex-ca86768db99a1d87"
                          ><span class="mord mathnormal">x</span></span
                        ></span
                      ><span class="katex-268c4630fc53e737"
                        ><span class="pstrut katex-3ac4c1d77ccd6fb1"></span
                        ><span class="hide-tail katex-26850a26ca4fa453"
                          ><svg
                            height="1.08em"
                            preserveaspectratio="xMinYMin slice"
                            viewbox="0 0 400000 1080"
                            width="400em"
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"
                            ></path></svg></span></span></span
                    ><span class="vlist-s">​</span></span
                  ><span class="vlist-r"
                    ><span class="vlist katex-1b9df330ac67e468"
                      ><span></span></span></span></span></span
              ><span class="mord">/</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord"><span class="mord mathnormal">x</span></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prime_factor</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, primes: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Prime factorizes a number, given a precomputed list of primes. """</span>
    l = <span class="hljs-built_in">set</span>()
    rt = <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes:
        <span class="hljs-keyword">if</span> p &gt; rt:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">while</span> n % p == <span class="hljs-number">0</span>:
            n = n//p
            l.add(p)
    <span class="hljs-keyword">if</span> n != <span class="hljs-number">1</span>:
        l.add(n)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(l)</code></pre>
      <h3 id="binary"><a class="header-anchor" href="#binary">Binary</a></h3>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/16/Slides16.pdf"
          >Most Significant Bit</a
        >
        - <a href="">Verification</a> - Complexity: Can be done in
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mn>1</mn><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(1)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord">1</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        with some work
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">msb</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the index of the most significant bit of n. """</span>
    <span class="hljs-keyword">return</span> n.bit_length() - <span class="hljs-number">1</span></code></pre>
      <p>
        <a
          href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan"
          >Brian Kernighan's set bit count</a
        >
        - <a href="">Verification: Othello</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>x</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log x)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">x</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_pos</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Finds the number of 1's in a number. """</span>
    l = []
    <span class="hljs-keyword">while</span> x:
        xp = x &amp; (x - <span class="hljs-number">1</span>)
        l.append((x - xp).bit_length() - <span class="hljs-number">1</span>)
        x = xp
    <span class="hljs-keyword">return</span> l</code></pre>
      <p>
        <a href="">Binary Counter</a> - <a href="">Verification</a> -
        Complexity: amortized
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mn>1</mn><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(1)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord">1</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        over
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mi>n</mi></mrow
                ><annotation encoding="application/x-tex">
                  n
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-85c92d966084c2b4"></span
              ><span class="mord mathnormal">n</span></span
            ></span
          ></span
        >
        operations
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">c: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Increments a binary counter. """</span>
    i = <span class="hljs-number">1</span>
    l = <span class="hljs-number">1</span> &lt;&lt; m
    <span class="hljs-keyword">while</span> i &lt; l <span class="hljs-keyword">and</span> c &amp; i &gt; <span class="hljs-number">0</span>:
        c ^= i
        i &lt;&lt;= <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> i &lt; l:
        c ^= i
    <span class="hljs-keyword">return</span> c</code></pre>
      <h3 id="matrices">
        <a class="header-anchor" href="#matrices">Matrices</a>
      </h3>
      <p>Miscellaneous operations</p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dotp</span>(<span class="hljs-params">u: <span class="hljs-built_in">list</span>, v: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Dot product. """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(u[i]*v[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(u)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">col</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Column of a matrix. """</span>
    <span class="hljs-keyword">return</span> [m[j][i] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">mat_mult</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Matrix multiplication. """</span>
    <span class="hljs-keyword">return</span> [[dotp(a[i], col(b, j)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b[<span class="hljs-number">0</span>]))]
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a))]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Identity matrix of size n x n. """</span>
    <span class="hljs-keyword">return</span> [[<span class="hljs-built_in">int</span>(i == j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_mat</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Pretty prints a matrix. """</span>
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m:
        <span class="hljs-built_in">print</span>(row)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">mat_exp</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Returns A^k. """</span>
    v = identity(<span class="hljs-built_in">len</span>(A))
    <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            v = mat_mult(v, A)
        k &gt;&gt;= <span class="hljs-number">1</span>
        A = mat_mult(A, A)
    <span class="hljs-keyword">return</span> v</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Gaussian_elimination"
          >Gauss–Jordan elimination</a
        >
        -
        <a href="https://foobar.withgoogle.com/">Verification: Google Foobar</a>
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><msup><mi>n</mi><mn>3</mn></msup
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n^3)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-d91866fb678685cf"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord"
                ><span class="mord mathnormal">n</span
                ><span class="msupsub"
                  ><span class="vlist-t"
                    ><span class="vlist-r"
                      ><span class="vlist katex-b3aa06341d751ec2"
                        ><span class="katex-00abc151c90866a2"
                          ><span class="pstrut katex-1527d00b389b9857"></span
                          ><span class="sizing reset-size6 size3 mtight"
                            ><span class="mord mtight">3</span></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ></span
                ></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">m</span>):
    <span class="hljs-string">""" Inverts a matrix. """</span>
    N = <span class="hljs-built_in">len</span>(m)
    <span class="hljs-comment"># augment matrix with identity</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        m[i] += [F(i == j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-comment"># get first nonzero entry</span>
        pivot = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c, N) <span class="hljs-keyword">if</span> m[i][c] != F(<span class="hljs-number">0</span>)][<span class="hljs-number">0</span>]
        m[c], m[pivot] = m[pivot], m[c]
        v = m[c][c]
        <span class="hljs-comment"># set pivot value to 1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m[c])):
            m[c][i] /= v
        <span class="hljs-comment"># make all zeros</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">if</span> r != c:
                v = m[r][c]
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m[r])):
                    m[r][i] -= v*m[c][i]

    <span class="hljs-keyword">return</span> [row[N:] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m]</code></pre>
      <h3 id="linear_programming">
        <a class="header-anchor" href="#linear_programming"
          >Linear Programming</a
        >
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Simplex_algorithm"
          >Simplex Algorithm</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mo stretchy="false">?</mo><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(?)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mclose">?)</span></span
            ></span
          ></span
        >
        (see
        <a href="https://en.wikipedia.org/wiki/Smoothed_analysis"
          >smoothed analysis</a
        >)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_dict</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">""" Converts a list into a dictionary based off indexes. """</span>
    <span class="hljs-keyword">return</span> {i + <span class="hljs-number">1</span>: l[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l))}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">prog_dict</span>(<span class="hljs-params">A, b, c, contypes, t, nonneg</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">"""
    Converts the easier list representation to a more general
    dictionary representation used by the simplex algorithm.
    """</span>
    <span class="hljs-keyword">return</span> (
        {v + <span class="hljs-number">1</span>: {i + <span class="hljs-number">1</span>: A[v][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A[v]))}
         <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))
        },
        list_dict(b), list_dict(c), list_dict(contypes),
        t, {x + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nonneg}
    )

<span class="hljs-keyword">def</span> <span class="hljs-title function_">negated</span>(<span class="hljs-params">d: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">""" Negates a row. """</span>
    <span class="hljs-keyword">return</span> {k: -v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">negate</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Negates a row vector. """</span>
    <span class="hljs-keyword">return</span> [-x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> l]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">general_standard</span>(<span class="hljs-params">A, b, c, contypes, t, nonneg</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Converts a general linear program into standard form. """</span>
    <span class="hljs-comment"># 1. The objective function is a minimization rather than a maximization</span>
    <span class="hljs-keyword">if</span> t == MIN:
        c = negate(c)
    <span class="hljs-comment"># 2. Variables without nonnegativity constraints</span>
    v = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> v &lt; <span class="hljs-built_in">len</span>(c):
        <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nonneg:
            c.insert(v + <span class="hljs-number">1</span>, -c[v])
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A)):
                A[i].insert(v + <span class="hljs-number">1</span>, -A[i][v])
            v += <span class="hljs-number">1</span>
        v += <span class="hljs-number">1</span>
    <span class="hljs-comment"># 3. Replace equality constraints with inequalities</span>
    tA, tb, tcontypes = [], [], []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A)):
        <span class="hljs-keyword">if</span> contypes[i] == EQ:
            tA += [A[i]]*<span class="hljs-number">2</span>
            tb += [b[i]]*<span class="hljs-number">2</span>
            tcontypes += [LEQ, GEQ]
        <span class="hljs-keyword">else</span>:
            tA.append(A[i])
            tb.append(b[i])
            tcontypes.append(contypes[i])
    A, b, contypes = tA, tb, tcontypes
    <span class="hljs-comment"># 4. Replace greater than equal to with less than or equal to</span>
    A = [negate(A[i]) <span class="hljs-keyword">if</span> contypes[i] == GEQ <span class="hljs-keyword">else</span> A[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))]
    b = [-b[i] <span class="hljs-keyword">if</span> contypes[i] == GEQ <span class="hljs-keyword">else</span> b[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b))]

    <span class="hljs-keyword">return</span> A, b, c

<span class="hljs-keyword">def</span> <span class="hljs-title function_">standard_slack</span>(<span class="hljs-params">A, b, c</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Converts a linear program in standard form to one in slack form. """</span>
    n = <span class="hljs-built_in">len</span>(A[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>
    A = {i + n: list_dict(A[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))}
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n)), <span class="hljs-built_in">set</span>(A.keys()), A,
            {i + n: b[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b))}, list_dict(c), <span class="hljs-number">0</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">general_slack</span>(<span class="hljs-params">prog</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Converts a general linear program into slack form. """</span>
    <span class="hljs-keyword">return</span> standard_slack(*general_standard(*prog))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pivot</span>(<span class="hljs-params">N, B, A, b, c, v, l, e</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Returns the new linear program after replacing x_l with x_e. """</span>
    <span class="hljs-comment"># Compute coefficients for the equation with the new basic variable x_e.</span>
    bp, cp, Ap = {}, {}, {v: {} <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> B - {l} | {e}}
    bp[e] = b[l]/A[l][e]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
        Ap[e][j] = A[l][j]/A[l][e]
    Ap[e][l] = <span class="hljs-number">1</span>/A[l][e]
    <span class="hljs-comment"># Compute coefficients of the remaining constraints.</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> B - {l}:
        bp[i] = b[i] - A[i][e]*bp[e]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
            Ap[i][j] = A[i][j] - A[i][e]*Ap[e][j]
        Ap[i][l] = -A[i][e]*Ap[e][l]
    <span class="hljs-comment"># Compute objective function</span>
    vp = v + c[e]*bp[e]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
        cp[j] = c[j] - c[e]*Ap[e][j]
    cp[l] = -c[e]*Ap[e][l]
    <span class="hljs-comment"># Compute new sets of basic and nonbasic variables.</span>
    Np = N - {e} | {l}
    Bp = B - {l} | {e}

    <span class="hljs-keyword">return</span> Np, Bp, Ap, bp, cp, vp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">N, B, A, b, c, v</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">"""
    Solves a linear program in slack form
    whose initial basic solution is feasible.
    """</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">any</span>(x &gt; EPSILON <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> c.values()):
        <span class="hljs-comment"># Bland's rule for both e and l</span>
        e = <span class="hljs-built_in">sorted</span>(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> N <span class="hljs-keyword">if</span> c[i] &gt; EPSILON)[<span class="hljs-number">0</span>]
        l = <span class="hljs-built_in">min</span>(B, key=<span class="hljs-keyword">lambda</span> i:
                (b[i]/A[i][e] <span class="hljs-keyword">if</span> A[i][e] &gt; EPSILON <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), i)
               )
        <span class="hljs-keyword">if</span> A[l][e] &lt;= EPSILON:
            <span class="hljs-keyword">return</span> UNBOUNDED + <span class="hljs-string">"$"</span>
        N, B, A, b, c, v = pivot(N, B, A, b, c, v, l, e)
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">tuple</span>(b.get(i, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(N) + <span class="hljs-number">1</span>)),
            v, (N, B, A, b, c, v))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_simplex</span>(<span class="hljs-params">A, b, c</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">"""
    Determines whether or not a linear program is feasible, and if it
    is, returns a slack form whose initial basic solution is feasible.
    """</span>
    k = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b)), key=<span class="hljs-keyword">lambda</span> i: b[i])
    <span class="hljs-comment"># initial basic solution feasible</span>
    <span class="hljs-keyword">if</span> b[k] &gt;= EPSILON:
        <span class="hljs-keyword">return</span> standard_slack(A, b, c)
    <span class="hljs-comment"># objective function -x_0</span>
    cp = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(c) + <span class="hljs-number">1</span>)}
    cp[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>
    N, B, A, b, c, v = standard_slack(A, b, c)
    <span class="hljs-comment"># add -x_0 to each equation in the linear program</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A:
        A[i][<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>
    N |= {<span class="hljs-number">0</span>}
    N, B, A, b, cp, v = pivot(N, B, A, b, cp, v, <span class="hljs-built_in">len</span>(N) + k, <span class="hljs-number">0</span>)
    x, v, (N, B, A, b, cp, v) = solve(N, B, A, b, cp, v)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(v) &lt;= EPSILON:
        N -= {<span class="hljs-number">0</span>}
        <span class="hljs-comment"># remove x_0 from constraints</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A:
            <span class="hljs-keyword">del</span> A[i][<span class="hljs-number">0</span>]
        <span class="hljs-comment"># substitute to form objective function</span>
        cp = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> N}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> A:
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> A[i]:
                    cp[j] -= c[i]*A[i][j]
                v += c[i]*b[i]
            <span class="hljs-keyword">else</span>:
                cp[i] += c[i]
        <span class="hljs-keyword">return</span> N, B, A, b, cp, v
    <span class="hljs-keyword">return</span> INFEASIBLE

<span class="hljs-keyword">def</span> <span class="hljs-title function_">simplex</span>(<span class="hljs-params">prog</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Solves an arbitrary linear program in standard form. """</span>
    slack = initialize_simplex(*prog)
    <span class="hljs-keyword">if</span> slack == INFEASIBLE:
        <span class="hljs-keyword">return</span> INFEASIBLE
    <span class="hljs-keyword">return</span> solve(*slack)[:-<span class="hljs-number">1</span>]</code></pre>
      <h3 id="fast_fourier_transform">
        <a class="header-anchor" href="#fast_fourier_transform"
          >Fast Fourier Transform</a
        >
      </h3>
      <p>
        <a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-2"
          >Cooley–Tukey Recursive FFT</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> cmath, math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, inv: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the DFT of a with recursion and complex roots of unity. """</span>
    n = <span class="hljs-built_in">len</span>(a)
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> a
    wn = cmath.exp((-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> inv <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)*<span class="hljs-number">2</span>*cmath.pi*<span class="hljs-number">1j</span>/n)
    w = <span class="hljs-number">1</span>
    y0, y1 = recur_fft(a[::<span class="hljs-number">2</span>], inv), recur_fft(a[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>], inv)
    y = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n &gt;&gt; <span class="hljs-number">1</span>):
        t = w*y1[k]
        y[k] = y0[k] + t
        y[k + (n &gt;&gt; <span class="hljs-number">1</span>)] = y0[k] - t
        w *= wn
    <span class="hljs-keyword">return</span> y

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_recur_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the inverse DFT of a. """</span>
    <span class="hljs-keyword">return</span> [x/<span class="hljs-built_in">len</span>(a) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> recur_fft(a, <span class="hljs-literal">True</span>)]</code></pre>
      <p>
        <a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-5"
          >Cooley–Tukey Iterative FFT</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rev_increment</span>(<span class="hljs-params">c: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Increments a reverse binary counter. """</span>
    i = <span class="hljs-number">1</span> &lt;&lt; (m - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> c &amp; i &gt; <span class="hljs-number">0</span>:
        c ^= i
        i &gt;&gt;= <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> c ^ i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bit_rev_copy</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Constructs an initial order from a by reversing the bits of the index. """</span>
    n, m = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(a).bit_length() - <span class="hljs-number">1</span>
    A = [<span class="hljs-number">0</span>]*n
    c = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        A[c] = a[i]
        c = rev_increment(c, m)
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">iter_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, inv: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the DFT iteratively. """</span>
    n = <span class="hljs-built_in">len</span>(a)
    A = bit_rev_copy(a)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n.bit_length()):
        m = <span class="hljs-number">1</span> &lt;&lt; s
        wm = cmath.exp((-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> inv <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)*<span class="hljs-number">2</span>*cmath.pi*<span class="hljs-number">1j</span>/m)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, m):
            w = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m &gt;&gt; <span class="hljs-number">1</span>):
                t = w*A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)]
                u = A[k + j]
                A[k + j] = u + t
                A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)] = u - t
                w *= wm
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_iter_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the inverse DFT of a. """</span>
    <span class="hljs-keyword">return</span> [x/<span class="hljs-built_in">len</span>(a) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iter_fft(a, <span class="hljs-literal">True</span>)]</code></pre>
      <p>Readings for the following number theoretic FFT algorithms:</p>
      <ul>
        <li>
          <p>
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"
              >Euler's totient function</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://en.wikipedia.org/wiki/Primitive_root_modulo_n"
              >Primitive root modulo n</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://cs170.org/assets/pdf/hw03-sol.pdf"
              >Application of FFT to polynomial multiplication</a
            >
          </p>
        </li>
        <li>
          <p>
            <a
              href="https://www.nayuki.io/page/number-theoretic-transform-integer-dft"
              >The Number Theoretic Transform (NTT)</a
            >
          </p>
        </li>
      </ul>
      <p>
        <a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-7"
          >Iterative FFT with modulo (NTT)</a
        >
        -
        <a href="https://www.spoj.com/problems/MAXMATCH/"
          >Verification: SPOJ MAXMATCH</a
        >
        - Complexity: O(n log n)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_kp</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">"""
    Finds the smallest k such that p = kn + 1 is prime.
    pi(n) = n/log n, so the probability of a random number
    being prime is 1/log n, expect to try log n numbers
    until finding a prime - expected O((sqrt n)(log n)).
    """</span>
    k, p = <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> prime(p):
        k += <span class="hljs-number">1</span>
        p += n
    <span class="hljs-keyword">return</span> k, p

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_generator</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">"""
    Euler's totient function phi(n) gives the
    order of a modulo multiplicative group mod p.
    phi(p) = p - 1 = kn
    prime factors of kn are 2, maybe k
    expected O(log^8 ish n)
    """</span>
    prime_factors = [<span class="hljs-number">2</span>] + ([k] <span class="hljs-keyword">if</span> prime(k) <span class="hljs-keyword">else</span> [])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):
        <span class="hljs-comment"># coprime and thus in the group</span>
        <span class="hljs-keyword">if</span> gcd(i, p) == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(mod_exp(i, k*n//factor, p) != <span class="hljs-number">1</span>
                   <span class="hljs-keyword">for</span> factor <span class="hljs-keyword">in</span> prime_factors):
                <span class="hljs-keyword">return</span> i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_wp</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">"""
    Returns w, the principal nth root of unity
    and p, the prime determining the mod.
    """</span>
    k, p = find_kp(n)
    g = find_generator(n, k, p)
    <span class="hljs-keyword">return</span> mod_exp(g, k, p), p

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_w</span>(<span class="hljs-params">w: <span class="hljs-built_in">int</span>, N: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns w, the principal nth root of unity for n. """</span>
    <span class="hljs-keyword">return</span> mod_exp(w, <span class="hljs-number">1</span> &lt;&lt; (N - n + <span class="hljs-number">1</span>), p)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Compute the DFT iteratively with modulo instead of complex numbers. """</span>
    n, lgn = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(a).bit_length()
    A = bit_rev_copy(a)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, lgn):
        m = <span class="hljs-number">1</span> &lt;&lt; s
        wm = mod_exp(wn, <span class="hljs-number">1</span> &lt;&lt; (lgn - s - <span class="hljs-number">1</span>), p)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, m):
            w = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m &gt;&gt; <span class="hljs-number">1</span>):
                t = w*A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)]
                u = A[k + j]
                A[k + j] = (u + t) % p
                A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)] = (u - t) % p
                w = (w*wm) % p
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the inverse DFT of a. """</span>
    wn, n1 = inv(wn, p), inv(<span class="hljs-built_in">len</span>(a), p)
    <span class="hljs-keyword">return</span> [(x*n1) % p <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> int_fft(a, wn, p)]</code></pre>
      <p>
        <a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-7"
          >Recursive FFT with modulo (NTT)</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes the DFT of a with recursion and modulo. """</span>
    n = <span class="hljs-built_in">len</span>(a)
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> a
    w = <span class="hljs-number">1</span>
    y0, y1 = int_fft(a[::<span class="hljs-number">2</span>], (wn*wn) % p, p), int_fft(a[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>], (wn*wn) % p, p)
    y = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n &gt;&gt; <span class="hljs-number">1</span>):
        t = (w*y1[k]) % p
        y[k] = (y0[k] + t) % p
        y[k + (n &gt;&gt; <span class="hljs-number">1</span>)] = (y0[k] - t) % p
        w = (w*wn) % p
    <span class="hljs-keyword">return</span> y</code></pre>
      <p>
        Polynomial Multiplication with the FFT -
        <a href="https://www.spoj.com/problems/POLYMUL/"
          >Verification: SPOJ POLYMUL</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <p>
        Note: make sure
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mi>p</mi></mrow
                ><annotation encoding="application/x-tex">
                  p
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-0b48a9ef2786725a"></span
              ><span class="mord mathnormal">p</span></span
            ></span
          ></span
        >
        is bigger than
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><msup><mi>m</mi><mn>2</mn></msup
                  ><mi>n</mi></mrow
                ><annotation encoding="application/x-tex">
                  m^2 n
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-b3aa06341d751ec2"></span
              ><span class="mord"
                ><span class="mord mathnormal">m</span
                ><span class="msupsub"
                  ><span class="vlist-t"
                    ><span class="vlist-r"
                      ><span class="vlist katex-b3aa06341d751ec2"
                        ><span class="katex-00abc151c90866a2"
                          ><span class="pstrut katex-1527d00b389b9857"></span
                          ><span class="sizing reset-size6 size3 mtight"
                            ><span class="mord mtight">2</span></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ></span
                ></span
              ><span class="mord mathnormal">n</span></span
            ></span
          ></span
        >, where
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mi>m</mi></mrow
                ><annotation encoding="application/x-tex">
                  m
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-85c92d966084c2b4"></span
              ><span class="mord mathnormal">m</span></span
            ></span
          ></span
        >
        is the biggest number in the array and
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mi>n</mi></mrow
                ><annotation encoding="application/x-tex">
                  n
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-85c92d966084c2b4"></span
              ><span class="mord mathnormal">n</span></span
            ></span
          ></span
        >
        is the length of the array.
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mirror</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">"""
    Mirrors a such that the resulting list has a length which is a power of 2.
    """</span>
    n, np = <span class="hljs-built_in">len</span>(a), <span class="hljs-number">1</span> &lt;&lt; math.ceil(math.log2(<span class="hljs-built_in">len</span>(a)))
    a += [<span class="hljs-number">0</span>]*(np - n)
    <span class="hljs-comment"># for i in range(np - n):</span>
    <span class="hljs-comment">#     a[n + i] = a[n - i - 2]</span>
    <span class="hljs-keyword">return</span> a

<span class="hljs-keyword">def</span> <span class="hljs-title function_">poly_mult</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">list</span>, w: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Multiplies two polynomials via the modular FFT. """</span>
    m = <span class="hljs-built_in">len</span>(a) + <span class="hljs-built_in">len</span>(b) - <span class="hljs-number">1</span>
    n = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b))
    <span class="hljs-comment"># make both lists the same size and degree bound 2n instead of n</span>
    ap = mirror(a + [<span class="hljs-number">0</span>]*(n - <span class="hljs-built_in">len</span>(a)) + [<span class="hljs-number">0</span>]*n)
    bp = mirror(b + [<span class="hljs-number">0</span>]*(n - <span class="hljs-built_in">len</span>(b)) + [<span class="hljs-number">0</span>]*n)
    w = get_w(w, N, <span class="hljs-built_in">len</span>(ap).bit_length(), p)
    ap, bp = int_fft(ap, w, p), int_fft(bp, w, p)
    <span class="hljs-keyword">return</span> inv_int_fft([ap[i]*bp[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ap))], w, p)[:m]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ntt_sign</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Assumes that substantial numbers are signed and therefore negative. """</span>
    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">if</span> x &lt; (p &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> x - p <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> l]

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    N = <span class="hljs-number">20</span>
    w, p = find_wp(<span class="hljs-number">1</span> &lt;&lt; N)</code></pre>
      <p>
        <a
          href="https://en.wikipedia.org/wiki/Multidimensional_discrete_convolution"
          >2D Convolution</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>m</mi><mi>log</mi><mo>⁡</mo
                  ><mrow><mi>n</mi><mi>m</mi></mrow
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(nm \log{nm})
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal">nm</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord"><span class="mord mathnormal">nm</span></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span>, pad=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Flattens a matrix into a list. """</span>
    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> row + [<span class="hljs-number">0</span>]*pad]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">reshape</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Shapes a list into a M x N matrix."""</span>
    <span class="hljs-keyword">return</span> [[l[r*n + c] <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">conv</span>(<span class="hljs-params">h: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">list</span></span>):
    <span class="hljs-string">""" Computes the 2D convolution. """</span>
    M, N, H, W = <span class="hljs-built_in">len</span>(x), <span class="hljs-built_in">len</span>(x[<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(h), <span class="hljs-built_in">len</span>(h[<span class="hljs-number">0</span>])
    <span class="hljs-comment"># need to pad the columns to the final size</span>
    h, x = flatten(h, N - <span class="hljs-number">1</span>), flatten(x, W - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> reshape(fft(h, x), M + H - <span class="hljs-number">1</span>, N + W - <span class="hljs-number">1</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">prune</span>(<span class="hljs-params">h: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Prunes a convolution for the specific K x K filter case. """</span>
    m, k = conv(h, x), <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(h), <span class="hljs-built_in">len</span>(x))
    pad = (k - <span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> [row[pad:-pad] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m[pad:-pad]]</code></pre>
      <h2 id="strings"><a class="header-anchor" href="#strings">Strings</a></h2>
      <h3 id="suffix_structures">
        <a class="header-anchor" href="#suffix_structures">Suffix Structures</a>
      </h3>
      <h4 id="suffix_array">
        <a class="header-anchor" href="#suffix_array">Suffix Array</a>
      </h4>
      <p>
        Reference paper:
        <a href="https://doi.org/10.1109/DCC.2009.42"
          ><em
            >Linear Suffix Array Construction by Almost Pure Induced-Sorting</em
          ></a
        >.
      </p>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/04/Small04.pdf"
          >Suffix Array by Induced Sorting</a
        >
        -
        <a href="https://www.spoj.com/problems/SARRAY/"
          >Verification: SPOJ SARRAY</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>m</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(m)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">m</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lms_block</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span>, t: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">""" Label each character of s with L (False) or S (True). """</span>
    j, l = i + <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>
    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> (l <span class="hljs-keyword">and</span> t[j]):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t[j]:
            l = <span class="hljs-literal">True</span>
        j += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> s[i:j]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">induced_sort</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span>, t: <span class="hljs-built_in">list</span>, blocks: <span class="hljs-built_in">list</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Induced sort of s. """</span>
    n = <span class="hljs-built_in">len</span>(s)
    c = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        c[s[i]] = c.get(s[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>

    <span class="hljs-comment"># modified bucket sort -</span>
    <span class="hljs-comment"># the size of the alphabet is bounded by the length of the string</span>
    order = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(c), <span class="hljs-built_in">max</span>(c) + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> c]
    b = {order[<span class="hljs-number">0</span>]: [<span class="hljs-number">0</span>, c[order[<span class="hljs-number">0</span>]] - <span class="hljs-number">1</span>]}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(order)):
        b[order[i]] = [b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,
                       b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + c[order[i]]]

    sa = [-<span class="hljs-number">1</span>]*n
    <span class="hljs-keyword">if</span> blocks <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):
            <span class="hljs-comment"># LMS index</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> t[i]:
                sa[b[s[i]][<span class="hljs-number">1</span>]] = i
                b[s[i]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-comment"># given sorted order from recursive call</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(blocks):
            sa[b[s[i]][<span class="hljs-number">1</span>]] = i
            b[s[i]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-comment"># put L types from the front</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        j = sa[i] - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t[j]:
            sa[b[s[j]][<span class="hljs-number">0</span>]] = j
            b[s[j]][<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>

    <span class="hljs-comment"># reset right borders</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(order)):
        b[order[i]] = [b[order[i]][<span class="hljs-number">0</span>],
                       c[order[i]] + (b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)]

    <span class="hljs-comment"># put S types from the back</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        j = sa[i] - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t[j]:
            sa[b[s[j]][<span class="hljs-number">1</span>]] = j
            b[s[j]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> sa

<span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_array</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Construct the suffix array for the string s. """</span>
    <span class="hljs-comment"># convert a string to an array of integer ordinal values</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(s, <span class="hljs-built_in">str</span>):
        s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>, s))

    n = <span class="hljs-built_in">len</span>(s)
    <span class="hljs-comment"># True is "S" type and "L" is False</span>
    t = [<span class="hljs-literal">True</span>]*n
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> s[i] &lt; s[i + <span class="hljs-number">1</span>]:
            t[i] = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">elif</span> s[i] &gt; s[i + <span class="hljs-number">1</span>]:
            t[i] = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">else</span>:
            t[i] = t[i + <span class="hljs-number">1</span>]

    sa = induced_sort(s, t)

    <span class="hljs-comment"># LMS blocks</span>
    blocks = [sa[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)
              <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t[sa[i]] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t[sa[i] - <span class="hljs-number">1</span>]]

    <span class="hljs-comment"># name blocks</span>
    names = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(blocks)):
        names[blocks[i]] = names.get(blocks[i - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>) + \
            (i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> \
             lms_block(s, t, blocks[i]) != lms_block(s, t, blocks[i - <span class="hljs-number">1</span>])
            )
    blocks = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> names]

    <span class="hljs-comment"># reduced list guaranteed to be &lt; n/2 of the original</span>
    reduced = [names[block] <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]

    <span class="hljs-comment"># all distinct characters - base case</span>
    m = <span class="hljs-built_in">len</span>(reduced)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(reduced)) == m:
        sa1 = [<span class="hljs-number">0</span>]*(m + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            sa1[reduced[i] + <span class="hljs-number">1</span>] = i
    <span class="hljs-keyword">else</span>:
        sa1 = suffix_array(reduced + [-<span class="hljs-number">1</span>])

    <span class="hljs-comment"># sort blocks by suffix array of reduced string</span>
    temp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(sa1)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(sa1)):
        temp[i] = blocks[sa1[i]]
    blocks = temp

    sa = induced_sort(s, t, blocks)
    <span class="hljs-keyword">return</span> sa</code></pre>
      <h5 id="lcp_array">
        <a class="header-anchor" href="#lcp_array">LCP Array</a>
      </h5>
      <p>
        Reference paper:
        <a href="https://doi.org/10.1007/3-540-48194-X_17"
          ><em
            >Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and
            Its Applications</em
          ></a
        >
      </p>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/03/Slides03.pdf"
          >Kasai</a
        >
        -
        <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=768"
          >Verification: USACO Standing Out</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>m</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(m)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">m</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcp_array</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">"""" Construct the LCP array given a string s and its suffix array sa. """</span>
    n = <span class="hljs-built_in">len</span>(s)
    rank = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        rank[sa[i]] = i

    lcp = [<span class="hljs-number">0</span>]*(n - <span class="hljs-number">1</span>)
    h = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">if</span> rank[i] &gt; <span class="hljs-number">1</span>:
            <span class="hljs-comment"># suffix before rank[i] in the suffix array</span>
            k = sa[rank[i] - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">while</span> s[i + h] == s[k + h]:
                h += <span class="hljs-number">1</span>
            lcp[rank[i] - <span class="hljs-number">1</span>] = h
            <span class="hljs-keyword">if</span> h &gt; <span class="hljs-number">0</span>:
                h -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> lcp</code></pre>
      <h5 id="generalized_suffix_arrays">
        <a class="header-anchor" href="#generalized_suffix_arrays"
          >Generalized Suffix Arrays</a
        >
      </h5>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/02/Slides02.pdf"
          >Generalized Suffix Arrays</a
        >
        -
        <a href="http://www.spoj.com/problems/LPS/">Verification: SPOJ LPS</a> -
        Complexity: O(m)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generalized_suffix_array</span>(<span class="hljs-params">words: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Build a single suffix array on the concatenation of multiple words. """</span>
    n = [v <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words)
         <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> (<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>, word)) + [i - <span class="hljs-built_in">len</span>(words)])]
    <span class="hljs-keyword">return</span> n, suffix_array(n)</code></pre>
      <h4 id="suffix_tree">
        <a class="header-anchor" href="#suffix_tree">Suffix Tree</a>
      </h4>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/04/Small04.pdf"
          >Suffix Trees</a
        >
        -
        <a href="http://www.spoj.com/problems/STAMMER/"
          >Verification: SPOJ STAMMER</a
        >
        - Complexity: O(m)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuffixTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span>, *,
                 start: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span>, end: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># cartesian tree variables</span>
        <span class="hljs-comment"># stores the LCP value for internal nodes</span>
        <span class="hljs-comment"># and the suffix index for leaf nodes</span>
        self.key = key
        self.parent = parent
        self.child = [left, right]

        <span class="hljs-comment"># suffix tree variables</span>
        <span class="hljs-comment"># keyed by first character (distinct)</span>
        self.children = {}
        <span class="hljs-comment"># start and end indexes in the string</span>
        self.start, self.end = start, end
        <span class="hljs-comment"># root contains a copy of the original string</span>
        self.s = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">""</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">""" Fancy tree printing (uses the original string to draw edges). """</span>
        <span class="hljs-keyword">if</span> self.s <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            rtn = []

            <span class="hljs-comment"># precompute heights</span>
            h = {<span class="hljs-literal">None</span>: -<span class="hljs-number">1</span>, self: <span class="hljs-number">0</span>}
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                    q.append(child)
                    h[child] = h[n] + <span class="hljs-number">1</span>

            <span class="hljs-comment"># actually compute string representation</span>
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                edge = self.s[n.start: n.end + <span class="hljs-number">1</span>] \
                    <span class="hljs-keyword">if</span> n.start <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.end <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>
                <span class="hljs-comment"># edge = (n.start, n.end)</span>
                rtn.append(<span class="hljs-string">"{}{} {}\n"</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">" "</span>*<span class="hljs-number">4</span>*h[n], n.key, edge))
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children, reverse=<span class="hljs-literal">True</span>):
                    q.append(n.children[child])
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(rtn)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"{}{}"</span>.<span class="hljs-built_in">format</span>(self.key, <span class="hljs-string">"$"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.children) == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">""" Whether s is a substring of the suffix tree. """</span>
        <span class="hljs-keyword">return</span> self.<span class="hljs-keyword">match</span>(s) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-string">"SuffixTree"</span>:
        <span class="hljs-string">"""
        Returns the subtree matching the string s, None if it does not exist.
        """</span>
        i = <span class="hljs-number">0</span>
        t = self
        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s):
            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t.children:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            t = t.children[s[i]]
            j = t.start
            <span class="hljs-keyword">while</span> j &lt;= t.end <span class="hljs-keyword">and</span> i &lt; <span class="hljs-built_in">len</span>(s):
                <span class="hljs-keyword">if</span> s[i] != self.s[j]:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
                j += <span class="hljs-number">1</span>
                i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> t

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
        <span class="hljs-string">""" Reports the index of each occurrence of s in the string. """</span>
        t = self.<span class="hljs-keyword">match</span>(s)
        l = []
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> l

        stk = [t]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
            n = stk.pop()
            <span class="hljs-comment"># leaf node</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.children) == <span class="hljs-number">0</span>:
                l.append(n.key)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                stk.append(child)

        <span class="hljs-keyword">return</span> l

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_array</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>:
        <span class="hljs-string">""" Inorder traversal yields a suffix array. """</span>
        sa = []
        stk = [self]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
            n = stk.pop()
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.children) == <span class="hljs-number">0</span>:
                sa.append(n.key)
            <span class="hljs-comment"># s log s where s is the size of the alphabet</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children, reverse=<span class="hljs-literal">True</span>):
                stk.append(n.children[k])

        <span class="hljs-keyword">return</span> sa

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_tree</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">""" Constructs a Cartesian tree for a LCP array in O(n). """</span>
    stk = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        c = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>].key &gt; l[i]:
            c = stk.pop()
        stk.append(SuffixTree(l[i], stk[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, c))
        <span class="hljs-comment"># add right child</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">1</span>:
            stk[-<span class="hljs-number">2</span>].child[<span class="hljs-number">1</span>] = stk[-<span class="hljs-number">1</span>]
            <span class="hljs-comment"># merge same values</span>
            <span class="hljs-comment"># if stk[-1].key == stk[-2].key:</span>
            <span class="hljs-comment">#     stk[-2].child[0] = stk[-1].child[0]</span>
            <span class="hljs-comment">#     stk.pop()</span>
    <span class="hljs-keyword">return</span> stk[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">n: SuffixTree, sa: <span class="hljs-built_in">list</span>, sword: <span class="hljs-built_in">list</span>,
            wstart: <span class="hljs-built_in">dict</span>, c: <span class="hljs-built_in">int</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-string">""" Adds a suffix of the string if the node is missing a child. """</span>
    <span class="hljs-keyword">if</span> n.child[c] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        end = wstart[sword[sa[i]] + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> \
            <span class="hljs-keyword">if</span> sword[sa[i]] + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(wstart) <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sa) - <span class="hljs-number">1</span>
        n.child[c] = SuffixTree(sa[i], n, start=sa[i] + n.key, end=end)
        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span>, t: SuffixTree,
        sword: <span class="hljs-built_in">list</span>, wstart: <span class="hljs-built_in">dict</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">""" Construct a suffix tree from the string s given its suffix array. """</span>
    stk = [(t, <span class="hljs-number">0</span>)]
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        i = process(n, sa, sword, wstart, <span class="hljs-number">0</span>, i)
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> p == <span class="hljs-number">2</span>:
            stk.pop()
            i = process(n, sa, sword, wstart, <span class="hljs-number">1</span>, i)
            <span class="hljs-comment"># merge same values</span>
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.key == n.parent.key:
                n.parent.child = [
                    child <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.parent.child + n.child
                    <span class="hljs-keyword">if</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> child.key != n.key
                ]
            <span class="hljs-comment"># label nodes with start and end values</span>
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.child:
                <span class="hljs-keyword">if</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                    <span class="hljs-comment"># min start index of children minus 1</span>
                    child.end = <span class="hljs-built_in">min</span>(child.child,
                                    key=<span class="hljs-keyword">lambda</span> x: x.start).start - <span class="hljs-number">1</span>
                    <span class="hljs-comment"># difference in LCP values</span>
                    child.start = child.end - (child.key - n.key) + <span class="hljs-number">1</span>
                <span class="hljs-comment"># key by first character of edge</span>
                n.children[s[child.start]] = child
                child.parent = n

        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = n.child[p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                stk.append((child, <span class="hljs-number">0</span>))
    <span class="hljs-comment"># copy original string to convert (start, end) into substrings</span>
    t.s = s
    <span class="hljs-comment"># additional state information</span>
    t.sword, t.wstart = sword, wstart
    <span class="hljs-keyword">return</span> t

<span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_tree</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span>, lcp: <span class="hljs-built_in">list</span>,
                word: <span class="hljs-built_in">list</span>=[], start: <span class="hljs-built_in">dict</span>={}</span>) -&gt; SuffixTree:
    <span class="hljs-string">""" Constructs a suffix tree for a string in O(n). """</span>
    <span class="hljs-keyword">return</span> dfs(s, sa, cartesian_tree(lcp),
               word <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(s),
               start <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(start) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> {s: <span class="hljs-number">0</span>})</code></pre>
      <h4 id="todo"><a class="header-anchor" href="#todo">TODO</a></h4>
      <p>Ukkonen's algorithm (direct construction)</p>
      <p>Lectures:</p>
      <ul>
        <li>
          <p>
            <a
              href="https://www2.cs.duke.edu/courses/fall14/compsci260/resources/suffix.trees.in.detail.pdf"
              >Duke</a
            >
          </p>
        </li>
        <li>
          <p>
            <a
              href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf"
              >CMU</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://web.stanford.edu/~mjkay/gusfield.pdf">Stanford</a>
          </p>
        </li>
      </ul>
      <h5 id="generalized_suffix_tree">
        <a class="header-anchor" href="#generalized_suffix_tree"
          >Generalized Suffix Tree</a
        >
      </h5>
      <p>
        <a
          href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1186/lectures/03/Small03.pdf"
          >Generalized Suffix Tree</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generalized_suffix_tree</span>(<span class="hljs-params">words: <span class="hljs-built_in">list</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">""" Construct a suffix tree on the concatenation of multiple words. """</span>
    s, sword, wstart = [], [], {}
    j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):
        wstart[i] = j
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word)):
            s.append(word[k])
            sword.append(i)
            j += <span class="hljs-number">1</span>
        s.append(<span class="hljs-built_in">chr</span>(<span class="hljs-number">128</span> + i))
        sword.append(i)
        j += <span class="hljs-number">1</span>
    sword.append(<span class="hljs-built_in">len</span>(words))

    s = <span class="hljs-string">""</span>.join(s) + <span class="hljs-string">"$"</span>
    sa = suffix_array(s)
    lcp = lcp_array(s, sa)

    t = suffix_tree(s, sa, lcp, sword, wstart)
    <span class="hljs-keyword">return</span> t</code></pre>
      <h5 id="suffix_tree_to_dag">
        <a class="header-anchor" href="#suffix_tree_to_dag"
          >Suffix Tree to DAG</a
        >
      </h5>
      <p>
        Suffix Tree to DAG - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_tree_dag</span>(<span class="hljs-params">t: SuffixTree</span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">""" Converts a suffix tree to a numeric DAG. """</span>
    ids, graph = {t: <span class="hljs-number">0</span>}, {}
    stk = [t]
    i = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">if</span> ids[n] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:
            graph[ids[n]] = []
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            ids[child] = i
            i += <span class="hljs-number">1</span>
            graph[ids[n]].append(ids[child])
            stk.append(child)
    <span class="hljs-keyword">return</span> ids, graph</code></pre>
      <h3 id="matching">
        <a class="header-anchor" href="#matching">Matching</a>
      </h3>
      <h4 id="aho-corasick">
        <a class="header-anchor" href="#aho-corasick">Aho-Corasick</a>
      </h4>
      <p>
        <a
          href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf"
          >Aho-Corasick</a
        >
        -
        <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=533"
          >Verification: USACO Censoring</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>n</mi
                  ><mo stretchy="false">)</mo><mo separator="true">,</mo
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>m</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo
                  ><mo stretchy="false">⟩</mo></mrow
                ><annotation encoding="application/x-tex">
                  \langle \mathcal{O}(n), \mathcal{O}(m + z) \rangle
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mopen">⟨</span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span><span class="mpunct">,</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">m</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-8b94b7a9c515f277">z</span
              ><span class="mclose">)⟩</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ch=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.children = {}                           <span class="hljs-comment"># pointers to children</span>
        self.ch = ch <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ch, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>  <span class="hljs-comment"># character</span>
        self.end = []                                <span class="hljs-comment"># represents a pattern</span>
        self.suffix = self.output = <span class="hljs-literal">None</span>             <span class="hljs-comment"># aho-corasick</span>

        <span class="hljs-comment"># create trie from list of patterns</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ch, <span class="hljs-built_in">list</span>):
            <span class="hljs-keyword">for</span> i, pattern <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(ch):
                self.add(pattern, i)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> self.ch == <span class="hljs-string">""</span>:
            rtn = []

            <span class="hljs-comment"># precompute heights</span>
            h = {<span class="hljs-literal">None</span>: -<span class="hljs-number">1</span>, self: <span class="hljs-number">0</span>}
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                    q.append(child)
                    h[child] = h[n] + <span class="hljs-number">1</span>

            <span class="hljs-comment"># actually compute string representation</span>
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                rtn.append(<span class="hljs-string">"{}{}{}:{} {}\n"</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">" "</span>*h[n], n.ch,
                                                   <span class="hljs-string">"$"</span> <span class="hljs-keyword">if</span> n.end <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,
                                                   h[n.suffix], h[n.output]))
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children.values(),
                                    reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x: x.ch):
                    q.append(child)
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(rtn)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"{}{}"</span>.<span class="hljs-built_in">format</span>(self.ch, <span class="hljs-string">"$"</span> <span class="hljs-keyword">if</span> self.end <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">""" Add s to the trie. """</span>
        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.children:
                self.children[ch] = Trie(ch)
            self = self.children[ch]
        self.end.append(<span class="hljs-built_in">id</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">root: Trie</span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-string">""" Computes the suffix links and output links for a given trie. """</span>
    q = deque([(<span class="hljs-literal">None</span>, root)])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        prev, n = q.popleft()
        <span class="hljs-keyword">if</span> prev <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-comment"># suffix links</span>
            x = prev.suffix
            <span class="hljs-keyword">while</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">if</span> n.ch <span class="hljs-keyword">in</span> x.children:
                    n.suffix = x.children[n.ch]
                    <span class="hljs-keyword">break</span>
                x = x.suffix
            <span class="hljs-keyword">else</span>:
                n.suffix = root

            <span class="hljs-comment"># output links</span>
            n.output = n.suffix <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.suffix.end) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> n.suffix.output
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            q.append((n, child))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">aho_corasick</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, patterns: <span class="hljs-built_in">list</span>, t: Trie=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Return all matches of patterns in s with the Aho-Corasick automata. """</span>
    <span class="hljs-comment"># create automata or use precomputed</span>
    <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        root = Trie(patterns)
        link(root)
        t = root

    <span class="hljs-comment"># find matches</span>
    matches = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(patterns)
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">while</span> ch <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t.children <span class="hljs-keyword">and</span> t.ch != <span class="hljs-string">""</span>:
            t = t.suffix
        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> t.children:
            t = t.children[ch]
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.end) &gt; <span class="hljs-number">0</span>:
            matches[t.end[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>
        word = t.output
        <span class="hljs-keyword">while</span> word <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            matches[word.end[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>
            word = word.output

    <span class="hljs-comment"># reuse values for duplicated patterns</span>
    stk = [root]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(n.end)):
            matches[n.end[i]] = matches[n.end[<span class="hljs-number">0</span>]]
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            stk.append(child)

    <span class="hljs-keyword">return</span> matches</code></pre>
      <h4 id="knuth-morris-pratt">
        <a class="header-anchor" href="#knuth-morris-pratt"
          >Knuth-Morris-Pratt</a
        >
      </h4>
      <p>
        <a href="https://web.stanford.edu/class/cs97si/10-string-algorithms.pdf"
          >Knuth-Morris-Pratt</a
        >
        -
        <a href="https://www.spoj.com/problems/EC_WORLD/"
          >Verification: SPOJ Rotations</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>n</mi
                  ><mo stretchy="false">)</mo><mo separator="true">,</mo
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>m</mi><mo stretchy="false">)</mo
                  ><mo stretchy="false">⟩</mo></mrow
                ><annotation encoding="application/x-tex">
                  \langle \mathcal{O}(n), \mathcal{O}(m) \rangle
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mopen">⟨</span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span><span class="mpunct">,</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">m</span
              ><span class="mclose">)⟩</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prefix_function</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    pi = [-<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(s)
    k = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):
        <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[k + <span class="hljs-number">1</span>] != s[i]:
            k = pi[k]
        <span class="hljs-keyword">if</span> s[k + <span class="hljs-number">1</span>] == s[i]:
            k += <span class="hljs-number">1</span>
        pi[i] = k
    <span class="hljs-keyword">return</span> pi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    pi = prefix_function(p)
    k = -<span class="hljs-number">1</span>
    matches = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):
        <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> p[k + <span class="hljs-number">1</span>] != s[i]:
            k = pi[k]
        <span class="hljs-keyword">if</span> p[k + <span class="hljs-number">1</span>] == s[i]:
            k += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(p) - <span class="hljs-number">1</span>:
            matches.append(i - <span class="hljs-built_in">len</span>(p) + <span class="hljs-number">1</span>)
            k = pi[k]
    <span class="hljs-keyword">return</span> matches</code></pre>
      <h2 id="dynamic_programming">
        <a class="header-anchor" href="#dynamic_programming"
          >Dynamic Programming</a
        >
      </h2>
      <h3 id="memoization">
        <a class="header-anchor" href="#memoization">Memoization</a>
      </h3>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache

sys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>)

<span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">*args, **kwargs</span>):
    ...

<span class="hljs-built_in">print</span>(recur.cache_info())</code></pre>
      <h2 id="graph_algorithms">
        <a class="header-anchor" href="#graph_algorithms">Graph Algorithms</a>
      </h2>
      <h3 id="traversals">
        <a class="header-anchor" href="#traversals">Traversals</a>
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Breadth-first_search"
          >Breadth-first search</a
        >
        - <a href="">Verification: AI</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">""" Breadth-first search on graph from start. """</span>
    seen = {start}
    q = deque([start])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n = q.popleft()
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(child)
                q.append(child)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Depth-first_search"
          >Depth-first search</a
        >
        - <a href="">Verification: AI</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">""" Depth-first search on graph from start. """</span>
    seen = {start}
    stk = [start]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(child)
                stk.append(child)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Tree_traversal"
          >Iterative post-order depth-first search</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, u</span>):
    <span class="hljs-string">""" Iterative post-order depth-first search. """</span>
    seen = {u}
    stk = [(u, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Tree_traversal"
          >Iterative post-order DFS (without indexing children)</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, u</span>):
    <span class="hljs-string">""" Iterative post-order depth-first search. """</span>
    done, seen = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                done.add(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    stk.append(child)</code></pre>
      <h4 id="eulerian_tour">
        <a class="header-anchor" href="#eulerian_tour">Eulerian Tour</a>
      </h4>
      <p>
        <a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian Tour</a>
        -
        <a href="https://train.usaco.org/usacoprob2?a=TpH8RHs6Taa&amp;S=fence"
          >Verification: USACO Training Riding the Fences</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eulerian_tour</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Finds a Eulerian tour or walk of the graph, whichever is possible. """</span>
    <span class="hljs-comment"># remove nodes with no edges</span>
    graph = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> graph.items() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v) &gt; <span class="hljs-number">0</span>}
    count = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">len</span>(graph[v]) % <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph)
    <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> count != <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-comment"># no such tour</span>
    start = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
        <span class="hljs-built_in">next</span>((v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[v]) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>))

    stk = [(start, <span class="hljs-number">0</span>)]
    tour = []
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            tour.append(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-comment"># edges have a unique id - (vertex, id)</span>
            <span class="hljs-keyword">if</span> (child[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen):
                stk.append((child[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>))
                seen.add(child[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> tour[::-<span class="hljs-number">1</span>]</code></pre>
      <h4 id="topological_sort">
        <a class="header-anchor" href="#topological_sort">Topological Sort</a>
      </h4>
      <p>
        <a href="https://en.wikipedia.org/wiki/Topological_sorting"
          >Topological Sort</a
        >
        -
        <a href="https://leetcode.com/problems/course-schedule-ii/"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, order: <span class="hljs-built_in">list</span>, done: <span class="hljs-built_in">set</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Depth-first search on graph from start. """</span>
    stk = [u]
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                done.add(n)
                order.append(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                    <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                        stk.append(child)
                    <span class="hljs-comment"># cycle, child processed before</span>
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">topological_sort</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Toplogical ordering on the directed acylic graph. """</span>
    order, done = [], <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> graph:
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
            <span class="hljs-keyword">if</span> dfs(graph, n, order, done):
                <span class="hljs-keyword">return</span> []
    <span class="hljs-keyword">return</span> order[::-<span class="hljs-number">1</span>]</code></pre>
      <h3 id="shortest_path">
        <a class="header-anchor" href="#shortest_path">Shortest Path</a>
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
          >Dijkstra</a
        >
        -
        <a href="https://train.usaco.org/usacoprob2?a=TpH8RHs6Taa&amp;S=butter"
          >Verification: USACO Training Sweet Butter</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi
                  ><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>V</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}((E + V) \log V)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">((</span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mclose">)</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        (I think)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> heapq

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, i</span>):
    <span class="hljs-string">""" Single-source shortest path for the graph starting at i. """</span>
    dists = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    dists[i] = <span class="hljs-number">0</span>
    pq = [(dists[i], i)]
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dist, n = heapq.heappop(pq)
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">continue</span>
        seen.add(n)
        <span class="hljs-keyword">for</span> c, w <span class="hljs-keyword">in</span> graph[n].items():
            <span class="hljs-keyword">if</span> dists[n] + w &lt; dists[c]:
                dists[c] = dists[n] + w
                paths[c] = n
                <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    heapq.heappush(pq, (dists[c], c))
    <span class="hljs-keyword">return</span> dists, paths</code></pre>
      <p>
        Dijkstra assuming the priority queue provides a
        <code>.update(key, value)</code> function
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_dijkstra</span>(<span class="hljs-params">graph, i</span>):
    <span class="hljs-string">""" Single-source shortest path for the graph starting at i. """</span>
    dists = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    dists[i] = <span class="hljs-number">0</span>
    pq = BST()
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph:
        pq.add((<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">if</span> v != i <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, v), v)

    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dist, n = pq.pop()
        dist = dist[<span class="hljs-number">0</span>]
        seen.add(n)
        <span class="hljs-keyword">for</span> c, w <span class="hljs-keyword">in</span> graph[n].items():
            <span class="hljs-keyword">if</span> dists[n] + w &lt; dists[c] <span class="hljs-keyword">and</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                temp = dists[c]
                dists[c] = dists[n] + w
                paths[c] = n
                pq.update((temp, c), c, (dists[c], c))
    <span class="hljs-keyword">return</span> dists, paths</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm"
          >Floyd-Warshall</a
        >
        -
        <a
          href="https://train.usaco.org/usacoprob2?a=TpH8RHs6Taa&amp;S=comehome"
          >Verification: USACO Training Bessie Come Home</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><msup><mi>V</mi><mn>3</mn></msup
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V^3)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-d91866fb678685cf"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord"
                ><span class="mord mathnormal katex-1330090babdf55df">V</span
                ><span class="msupsub"
                  ><span class="vlist-t"
                    ><span class="vlist-r"
                      ><span class="vlist katex-b3aa06341d751ec2"
                        ><span class="katex-00abc151c90866a2"
                          ><span class="pstrut katex-1527d00b389b9857"></span
                          ><span class="sizing reset-size6 size3 mtight"
                            ><span class="mord mtight">3</span></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ></span
                ></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd_warshall</span>():
    <span class="hljs-string">""" All-pairs shortest path for the graph. """</span>
    m = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)]*N <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            m[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> \
                (graph[i][j] <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> graph[i] <span class="hljs-keyword">else</span> m[i][j])

    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
                <span class="hljs-keyword">if</span> m[i][k] + m[k][j] &lt; m[i][j]:
                     m[i][j] = m[i][k] + m[k][j]</code></pre>
      <p>
        Floyd-Warshall for sparse graphs -
        <a href="https://train.usaco.org/usacoprob2?a=TpH8RHs6Taa&amp;S=cowtour"
          >Verification: USACO Training Cow Tours</a
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd_warshall</span>():
    <span class="hljs-string">""" All-pairs shortest path for the graph. """</span>
    m = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)]*N <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            m[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> \
                (graph[i][j] <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> graph[i] <span class="hljs-keyword">else</span> m[i][j])

    poss = [<span class="hljs-built_in">set</span>([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N) <span class="hljs-keyword">if</span> row[i] != <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m]

    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> poss[i]: <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> poss[k]:
                <span class="hljs-keyword">if</span> m[i][k] + m[k][j] &lt; m[i][j]:
                     m[i][j] = m[i][k] + m[k][j]
                     poss[i].add(j)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Taxicab_geometry"
          >Manhattan Distance</a
        >
      </p>
      <pre><code class="python hljs">manhat = <span class="hljs-keyword">lambda</span> i, j, x, y: <span class="hljs-built_in">abs</span>(i - x) + <span class="hljs-built_in">abs</span>(j - y)</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> -
        <a href="">Verification: AI</a> - Complexity: ???
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Astar</span>(<span class="hljs-params">start</span>):
    <span class="hljs-string">""" Single-source shortest path for the graph. """</span>
    seen = <span class="hljs-built_in">set</span>()
    pq = [(dist(start), start, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dis, n, moves = heapq.heappop(pq)
        <span class="hljs-keyword">if</span> n == goal:
            <span class="hljs-keyword">return</span> moves
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> get_children(n):
            heapq.heappush(pq,
                           (heuristic(child) + moves + <span class="hljs-number">1</span>, child, moves + <span class="hljs-number">1</span>)
                          )
        seen.add(n)</code></pre>
      <h3 id="union-find">
        <a class="header-anchor" href="#union-find">Union-find</a>
      </h3>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_18_Union_Find_and_MST.pdf"
          >Union-find (or disjoint-set)</a
        >
        -
        <a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=646"
          >Verification: USACO Closing</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>α</mi><mo stretchy="false">(</mo><mi>N</mi
                  ><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\alpha(N))
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-5001a512e1ef35f1">α</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-469634f8cda7614d">N</span
              ><span class="mclose">))</span></span
            ></span
          ></span
        >
      </p>
      <p>
        where
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow><mi>α</mi></mrow
                ><annotation encoding="application/x-tex">
                  \alpha
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-85c92d966084c2b4"></span
              ><span class="mord mathnormal katex-5001a512e1ef35f1"
                >α</span
              ></span
            ></span
          ></span
        >
        is the inverse
        <a href="https://en.wikipedia.org/wiki/Ackermann_function"
          >Ackermann function</a
        >.
      </p>
      <div class="centering border">
        <figure>
          <a href="https://cdn.myanimelist.net/images/characters/15/358414.jpg"
            ><img
              alt="Mikasa Ackerman"
              height="350"
              src="/assets/blog/algorithm-library/358414.webp"
              width="225"
          /></a>
          <figcaption>
            <a href="https://myanimelist.net/character/40881/Mikasa_Ackerman"
              >Mikasa Ackerman</a
            >.
          </figcaption>
        </figure>
      </div>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">union_init</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Initialize the union-find data structure. """</span>
    <span class="hljs-keyword">return</span> {i: i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)}, {i: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Find the root of u. """</span>
    <span class="hljs-keyword">if</span> parent[u] == u:
        <span class="hljs-keyword">return</span> u
    parent[u] = find(parent, parent[u])
    <span class="hljs-keyword">return</span> parent[u]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, size: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">""" Union the components of u and v. """</span>
    ur, vr = find(parent, u), find(parent, v)
    <span class="hljs-keyword">if</span> ur == vr:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    x, y = (ur, vr) <span class="hljs-keyword">if</span> size[ur] &lt; size[vr] <span class="hljs-keyword">else</span> (vr, ur)
    parent[x] = y
    size[y] += size[x]
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>
      <p>Iterative variant</p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Find the root of u. """</span>
    i = u
    <span class="hljs-keyword">while</span> parent[i] != i:
        i = parent[i]
    <span class="hljs-keyword">while</span> parent[u] != u:
        p = parent[u]
        parent[u] = i
        u = p
    <span class="hljs-keyword">return</span> i</code></pre>
      <h3 id="minimum_spanning_tree">
        <a class="header-anchor" href="#minimum_spanning_tree"
          >Minimum Spanning Tree</a
        >
      </h3>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_18_Union_Find_and_MST.pdf"
          >Kruskal</a
        >
        -
        <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=101"
          >Verification: USACO Simplify</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi
                  ><mo stretchy="false">)</mo><mo>=</mo
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>V</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(E \log E) = \mathcal{O}(E \log V)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span
              ><span class="mspace katex-b9d9edcedd93f43c"></span
              ><span class="mrel">=</span
              ><span class="mspace katex-b9d9edcedd93f43c"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kruskal</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Find the minimum spanning tree of the graph with Kruskal's. """</span>
    parent, size = {u: u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph}, {u: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph}
    span = []
    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>((graph[u][v], u, v)
                    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u] <span class="hljs-keyword">if</span> v &gt; u):
        w, u, v = e
        <span class="hljs-keyword">if</span> find(parent, u) != find(parent, v):
            span.append((w, u, v))
            union(parent, size, u, v)
    <span class="hljs-keyword">return</span> span</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim</a> -
        <a href="https://train.usaco.org/usacoprob2?a=TpH8RHs6Taa&amp;S=agrinet"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><msup><mi>V</mi><mn>2</mn></msup
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V^2)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-d91866fb678685cf"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord"
                ><span class="mord mathnormal katex-1330090babdf55df">V</span
                ><span class="msupsub"
                  ><span class="vlist-t"
                    ><span class="vlist-r"
                      ><span class="vlist katex-b3aa06341d751ec2"
                        ><span class="katex-00abc151c90866a2"
                          ><span class="pstrut katex-1527d00b389b9857"></span
                          ><span class="sizing reset-size6 size3 mtight"
                            ><span class="mord mtight">2</span></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ></span
                ></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prim</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Find the minimum spanning tree of the graph with Prim's. """</span>
    distances = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    tree = {i: <span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    size, cost = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
    tree[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m)):
        distances[i] = m[<span class="hljs-number">0</span>][i]
        paths[i] = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> size &lt; <span class="hljs-built_in">len</span>(m):
        i = <span class="hljs-built_in">min</span>(distances,
                key=<span class="hljs-keyword">lambda</span> x: distances[x] <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tree[x] <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>))
        size += <span class="hljs-number">1</span>
        cost += distances[i]
        tree[i] = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m)):
            <span class="hljs-keyword">if</span> distances[j] &gt; m[i][j]:
                distances[j] = m[i][j]
                paths[j] = i
    <span class="hljs-keyword">return</span> cost</code></pre>
      <h3 id="connected_components">
        <a class="header-anchor" href="#connected_components"
          >Connected Components</a
        >
      </h3>
      <p>Important if using recursion</p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
sys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">6</span>)</code></pre>
      <h4 id="undirected">
        <a class="header-anchor" href="#undirected">Undirected</a>
      </h4>
      <p>
        Connected components -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/I"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">""" Assign u and its children to the component num. """</span>
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        ids[n] = num
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
                ids[child] = num
                stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">connected</span>(<span class="hljs-params">graph</span>):
    <span class="hljs-string">""" Find the connected components of the graph. """</span>
    ids, num = {}, <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:
        <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
            assign(u, num, ids)
            num += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> ids, num</code></pre>
      <h4 id="directed_strongly_connected_components">
        <a class="header-anchor" href="#directed_strongly_connected_components"
          >Directed (Strongly connected components)</a
        >
      </h4>
      <p>Recursion bad - see iterative post-order/assign</p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>), l=deque(<span class="hljs-params">[]</span>)</span>):
    <span class="hljs-string">""" Visit u and its children. """</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
        seen.add(u)
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> reverse[u]:
            visit(v, seen, l)
        l.appendleft(u)
    <span class="hljs-keyword">return</span> seen, l

<span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">""" Assign u and its children to the component num. """</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
        ids[u] = num
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:
            assign(v, num, ids)
    <span class="hljs-keyword">return</span> ids</code></pre>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_01_Strongly_Connected_Components.pdf"
          >Kosaraju-Sharir</a
        >
        -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A"
          >Verification</a
        >
        - Complexity: O(V + E)
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">""" Assign u and its children to the component num. """</span>
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        ids[n] = num
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
                ids[child] = num
                stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>), l=deque(<span class="hljs-params">[]</span>)</span>):
    <span class="hljs-string">""" Visit u and its children. """</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [u]
    done = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                l.appendleft(n)
                done.add(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> reverse[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">kosaraju_sharir</span>(<span class="hljs-params">graph</span>):
    <span class="hljs-string">""" Find the strongly connected components with Kosaraju-Sharir. """</span>
    seen, l = <span class="hljs-built_in">set</span>(), deque([])
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:
        visit(u, seen, l)
    ids, num = {}, <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> l:
        <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
            assign(u, num, ids)
            num += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> ids, num</code></pre>
      <p>Recover components from ids</p>
      <pre><code class="python hljs">comps = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> ids.items():
    comps[value].append(key)</code></pre>
      <h3 id="tree"><a class="header-anchor" href="#tree">Tree</a></h3>
      <h4 id="lca"><a class="header-anchor" href="#lca">LCA</a></h4>
      <p>
        <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor"
          >Lowest Common Ancestor</a
        >
        - <a href="">Verification: PClassic</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mo stretchy="false">⟨</mo><mn>0</mn
                  ><mo separator="true">,</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>n</mi
                  ><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow
                ><annotation encoding="application/x-tex">
                  \langle 0, \mathcal{O}(n) \rangle
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mopen">⟨</span><span class="mord">0</span
              ><span class="mpunct">,</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)⟩</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">""" Breadth-first search on graph from start. """</span>
    heights = {}
    parents = {start: start}
    q = deque([(start, <span class="hljs-number">0</span>)])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n, h = q.popleft()
        heights[n] = h
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> heights:
                heights[child] = h + <span class="hljs-number">1</span>
                parents[child] = n
                q.append((child, h + <span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> heights, parents

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">heights, parents, u, v</span>):
    h1, h2 = heights[u], heights[v]
    x, y = (u, v) <span class="hljs-keyword">if</span> h1 &gt; h2 <span class="hljs-keyword">else</span> (v, u)
    <span class="hljs-keyword">while</span> h1 != h2:
        x = parents[x]
        <span class="hljs-keyword">if</span> h1 &gt; h2:
            h1 -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            h2 -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> x != y:
        x = parents[x]
        y = parents[y]
    <span class="hljs-keyword">return</span> x</code></pre>
      <h5 id="2n_jump_pointers">
        <a class="header-anchor" href="#2n_jump_pointers">2^n Jump Pointers</a>
      </h5>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_25_LCA.pdf"
          >Jump Pointers</a
        >
        -
        <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=576"
          >Verification: USACO Max Flow</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo
                  ><mi>n</mi><mo stretchy="false">)</mo
                  ><mo separator="true">,</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow
                ><annotation encoding="application/x-tex">
                  \langle \mathcal{O}(n \log n), \mathcal{O}(\log n) \rangle
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mopen">⟨</span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span><span class="mpunct">,</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)⟩</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">build_table</span>(<span class="hljs-params">parents: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Builds a 2^n jump pointer table in O(n log n) """</span>
    n, m = <span class="hljs-built_in">len</span>(parents), math.ceil(math.log2(<span class="hljs-built_in">len</span>(parents)))
    dp = [[<span class="hljs-number">0</span>]*m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i][<span class="hljs-number">0</span>] = parents[i]

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            dp[i][j + <span class="hljs-number">1</span>] = dp[dp[i][j]][j]

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">table: <span class="hljs-built_in">list</span>, u: <span class="hljs-built_in">int</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the ancestor d height above a node u in O(log d). """</span>
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> d &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> d &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            u = table[u][i]
        d &gt;&gt;= <span class="hljs-number">1</span>
        i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> u

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">heights: <span class="hljs-built_in">dict</span>, table: <span class="hljs-built_in">list</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the Lowest Common Ancestor (LCA) in O(log n) """</span>
    h1, h2 = heights[u], heights[v]
    x, y = (u, v) <span class="hljs-keyword">if</span> h1 &gt; h2 <span class="hljs-keyword">else</span> (v, u)
    x = jump(table, x, <span class="hljs-built_in">abs</span>(h1 - h2))
    <span class="hljs-keyword">if</span> x == y: <span class="hljs-keyword">return</span> x

    i = <span class="hljs-built_in">len</span>(table[x]) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> table[x][i] != table[y][i]:
            x, y = table[x][i], table[y][i]
        i -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> table[x][<span class="hljs-number">0</span>]</code></pre>
      <h5 id="lca_with_range_minimum_query">
        <a class="header-anchor" href="#lca_with_range_minimum_query"
          >LCA with Range Minimum Query</a
        >
      </h5>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1819/2019_2_11_LCA.pdf"
          >Euler Tour</a
        >
        -
        <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=576"
          >Verification: USACO Max Flow</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi
                  ><mo stretchy="false">(</mo><mi>n</mi
                  ><mo stretchy="false">)</mo><mo separator="true">,</mo
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mn>1</mn><mo stretchy="false">)</mo
                  ><mo stretchy="false">⟩</mo></mrow
                ><annotation encoding="application/x-tex">
                  \langle \mathcal{O}(n), \mathcal{O}(1) \rangle
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mopen">⟨</span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span><span class="mpunct">,</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord">1</span
              ><span class="mclose">)⟩</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">u</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Euler tour on the tree rooted at u. """</span>
    stk = [(u, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]
    seen = <span class="hljs-built_in">set</span>()
    seen.add(u)
    left, right, l = {}, [], []
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p, h = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()

            left[n] = <span class="hljs-built_in">len</span>(l)
            right.append(n)
            l.append(h)
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>, h)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>, h + <span class="hljs-number">1</span>))
                seen.add(child)

                left[n] = <span class="hljs-built_in">len</span>(l)
                right.append(n)
                l.append(h)
    <span class="hljs-keyword">return</span> left, right, l

indexes, inv, array = traversal(<span class="hljs-number">0</span>)
fh = fischer_heun(array)
l = inv[rmq(array, *fh, indexes[a], indexes[b])]</code></pre>
      <h4 id="heavy-light_decomposition">
        <a class="header-anchor" href="#heavy-light_decomposition"
          >Heavy-Light Decomposition</a
        >
      </h4>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1819/2019_3_15_HLD.pdf"
          >Heavy-Light Decomposition</a
        >
        -
        <a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=970"
          >Verification: USACO Milk Visits</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hld</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Heavy-light decomposition of the tree. """</span>
    parents = {start: start}
    heights = {start: <span class="hljs-number">0</span>}
    heavy = {}
    size = {u: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    largest = {u: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    stk = [(start, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                size[n] += size[child]
                <span class="hljs-comment"># heavy edge is the largest subtree out of a node's children</span>
                <span class="hljs-keyword">if</span> child != parents[n] <span class="hljs-keyword">and</span> size[child] &gt; largest[n]:
                    largest[n] = size[child]
                    heavy[n] = child
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
              stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> parents:
                parents[child] = n
                heights[child] = heights[n] + <span class="hljs-number">1</span>
                stk.append((child, <span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> parents, heights, heavy

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hld_decomp</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, heavy: <span class="hljs-built_in">dict</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Heavy-light decomposition of the tree. """</span>
    cur = <span class="hljs-number">0</span>
    head, indexes = {}, {}
    array = []
    seen = <span class="hljs-built_in">set</span>()
    seen.add(start)
    stk = [(start, start)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, h = stk.pop()
        head[n] = h
        indexes[n] = cur
        array.append(n)
        cur += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen <span class="hljs-keyword">and</span> child != heavy.get(n, <span class="hljs-literal">None</span>):
                seen.add(child)
                stk.append((child, child))
        <span class="hljs-comment"># traverse heavy edges first, since it's a stack it goes after</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> heavy:
            seen.add(heavy[n])
            stk.append((heavy[n], h))
    <span class="hljs-keyword">return</span> head, indexes, array

<span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">parents: <span class="hljs-built_in">dict</span>, heights: <span class="hljs-built_in">dict</span>, head: <span class="hljs-built_in">dict</span>,
          array: <span class="hljs-built_in">dict</span>, indexes: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    ans = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> head[u] != head[v]:
        u, v = (u, v) <span class="hljs-keyword">if</span> heights[head[u]] &gt; heights[head[v]] <span class="hljs-keyword">else</span> (v, u)
        mx = <span class="hljs-number">0</span>
        <span class="hljs-comment"># mx = rmq(array, indexes[head[u]], indexes[v])</span>
        ans = ans <span class="hljs-keyword">if</span> ans &gt; mx <span class="hljs-keyword">else</span> mx
        u = parents[head[u]]
    u, v = (u, v) <span class="hljs-keyword">if</span> heights[u] &lt; heights[v] <span class="hljs-keyword">else</span> (v, u)
    mx = <span class="hljs-number">0</span>
    <span class="hljs-comment"># mx = rmq(array, indexes[u], indexes[v])</span>
    ans = ans <span class="hljs-keyword">if</span> ans &gt; mx <span class="hljs-keyword">else</span> mx
    <span class="hljs-keyword">return</span> ans</code></pre>
      <h4 id="tree_to_array">
        <a class="header-anchor" href="#tree_to_array">Tree to Array</a>
      </h4>
      <p>
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/B"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><mo>+</mo><mi>E</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V + E)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mspace katex-74dc427d3e42f308"></span
              ><span class="mbin">+</span
              ><span class="mspace katex-74dc427d3e42f308"></span></span
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathnormal katex-258838068f140626">E</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_to_dag</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>)</span>):
    <span class="hljs-string">""" Turn a tree into a DAG. """</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [(u, <span class="hljs-number">0</span>)]
    seen.add(u)
    new = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)
                new[n].append(child)
    <span class="hljs-keyword">return</span> new

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>)</span>):
    <span class="hljs-string">""" Depth-first search on graph from start. """</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [(u, <span class="hljs-number">0</span>)]
    seen.add(u)
    indexes = {}
    used = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            <span class="hljs-keyword">if</span> p == <span class="hljs-number">0</span>:
                used += <span class="hljs-number">1</span>
                indexes[n] = (used, used)
            <span class="hljs-keyword">else</span>:
                l, r = indexes[graph[n][<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>], indexes[graph[n][-<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>
                indexes[n] = (l, r)
                used = r
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)
    <span class="hljs-keyword">return</span> indexes</code></pre>
      <h3 id="flow"><a class="header-anchor" href="#flow">Flow</a></h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"
          >Edmonds-Karp</a
        >
        -
        <a href="https://www.spoj.com/problems/MTOTALF/"
          >Verification: SPOJ MTOTALF</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>V</mi><msup><mi>E</mi><mn>2</mn></msup
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(V E^2)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-d91866fb678685cf"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal katex-1330090babdf55df">V</span
              ><span class="mord"
                ><span class="mord mathnormal katex-258838068f140626">E</span
                ><span class="msupsub"
                  ><span class="vlist-t"
                    ><span class="vlist-r"
                      ><span class="vlist katex-b3aa06341d751ec2"
                        ><span class="katex-00abc151c90866a2"
                          ><span class="pstrut katex-1527d00b389b9857"></span
                          ><span class="sizing reset-size6 size3 mtight"
                            ><span class="mord mtight">2</span></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ></span
                ></span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">c, f, s, t</span>):
    <span class="hljs-string">""" Breadth-first search on graph from start. """</span>
    q = deque([(s, <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>))])
    paths = {s: <span class="hljs-literal">None</span>}
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n, flow = q.popleft()
        <span class="hljs-keyword">if</span> n == t:
            <span class="hljs-keyword">return</span> flow, paths
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> c[n]:
            cf = c[n][child] - f[n][child]
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> paths <span class="hljs-keyword">and</span> cf &gt; <span class="hljs-number">0</span>:
                paths[child] = n
                q.append((child, <span class="hljs-built_in">min</span>(flow, cf)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">edmonds_karp</span>(<span class="hljs-params">c, s, t</span>):
    <span class="hljs-string">""" Compute the flow of the graph with Edmonds-Karp. """</span>
    f = {u: {v: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> c} <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> c}
    p = bfs(c, f, s, t)
    flow = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        df, path = p
        u, v = t, path[t]
        flow += df
        <span class="hljs-keyword">while</span> v <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            f[v][u] += df
            f[u][v] = -f[v][u]
            u, v = v, path[v]
        p = bfs(c, f, s, t)
    <span class="hljs-keyword">return</span> flow, f</code></pre>
      <p>Problems:</p>
      <p>Max Flow</p>
      <ul>
        <li>
          <p>
            <a href="http://poj.org/problem?id=1273"
              >http://poj.org/problem?id=1273</a
            >
            (USACO Drainage Ditches)
          </p>
        </li>
        <li>
          <p>
            <a href="https://codeforces.com/problemset/problem/843/E"
              >https://codeforces.com/problemset/problem/843/E</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://www.spoj.com/problems/POTHOLE/"
              >https://www.spoj.com/problems/POTHOLE/</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://www.spoj.com/problems/FASTFLOW/"
              >https://www.spoj.com/problems/FASTFLOW/</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="https://open.kattis.com/problems/maxflow"
              >https://open.kattis.com/problems/maxflow</a
            >
          </p>
        </li>
      </ul>
      <p>Dynamic</p>
      <ul>
        <li>
          <p>
            <a href="https://codeforces.com/problemset/problem/903/G"
              >https://codeforces.com/problemset/problem/903/G</a
            >
          </p>
        </li>
      </ul>
      <p>Min-cost</p>
      <ul>
        <li>
          <p>
            <a href="https://open.kattis.com/problems/mincostmaxflow"
              >https://open.kattis.com/problems/mincostmaxflow</a
            >
          </p>
        </li>
      </ul>
      <p>Extensions</p>
      <ul>
        <li>
          <p>
            Self edge: flow is 0 (<span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi
                      ><mo separator="true">,</mo><mi>u</mi
                      ><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>f</mi
                      ><mo stretchy="false">(</mo><mi>u</mi
                      ><mo separator="true">,</mo><mi>u</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      f(u, u) = -f(u, u)</annotation
                    ></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mord mathnormal katex-293f981920d0db87">f</span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal">u</span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal">u</span
                  ><span class="mclose">)</span
                  ><span class="mspace katex-b9d9edcedd93f43c"></span
                  ><span class="mrel">=</span
                  ><span class="mspace katex-b9d9edcedd93f43c"></span></span
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mord">−</span
                  ><span class="mord mathnormal katex-293f981920d0db87">f</span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal">u</span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal">u</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >), therefore capacity is 0
          </p>
        </li>
        <li>
          <p>
            Multiple edges between
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mo stretchy="false">(</mo><mi>u</mi
                      ><mo separator="true">,</mo><mi>v</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      (u, v)
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal">u</span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd">v</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >: one edge with the sum of the capacities
          </p>
        </li>
        <li>
          <p>
            Undirected graph: add
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mo stretchy="false">(</mo><mi>u</mi
                      ><mo separator="true">,</mo><mi>v</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      (u, v)
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal">u</span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd">v</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >
            and
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mo stretchy="false">(</mo><mi>v</mi
                      ><mo separator="true">,</mo><mi>u</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      (v, u)
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd">v</span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal">u</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >
          </p>
        </li>
        <li><p>Unweighted graph: weight of 1</p></li>
        <li>
          <p>
            If vertex
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow><mi>v</mi></mrow
                    ><annotation encoding="application/x-tex">
                      v
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-85c92d966084c2b4"></span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                    >v</span
                  ></span
                ></span
              ></span
            >
            has capacity
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow><mi>c</mi></mrow
                    ><annotation encoding="application/x-tex">
                      c
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-85c92d966084c2b4"></span
                  ><span class="mord mathnormal">c</span></span
                ></span
              ></span
            >: make new vertices
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><msub><mi>v</mi><mtext>in</mtext></msub></mrow
                    ><annotation encoding="application/x-tex">
                      v_\text{in}
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-4891f18275a5744f"></span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-c1a1c31017efdcea"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">in</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span></span></span></span
            >,
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><msub><mi>v</mi><mtext>out</mtext></msub></mrow
                    ><annotation encoding="application/x-tex">
                      v_\text{out}
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-4891f18275a5744f"></span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-3ebe6b8d14aeda59"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">out</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span></span></span></span
            >. All edges going into
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow><mi>v</mi></mrow
                    ><annotation encoding="application/x-tex">
                      v
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-85c92d966084c2b4"></span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                    >v</span
                  ></span
                ></span
              ></span
            >
            go into
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><msub><mi>v</mi><mtext>in</mtext></msub></mrow
                    ><annotation encoding="application/x-tex">
                      v_\text{in}
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-4891f18275a5744f"></span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-c1a1c31017efdcea"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">in</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span></span></span></span
            >, going out of
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow><mi>v</mi></mrow
                    ><annotation encoding="application/x-tex">
                      v
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-85c92d966084c2b4"></span
                  ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                    >v</span
                  ></span
                ></span
              ></span
            >
            goes from
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><msub><mi>v</mi><mtext>out</mtext></msub></mrow
                    ><annotation encoding="application/x-tex">
                      v_\text{out}
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-4891f18275a5744f"></span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-3ebe6b8d14aeda59"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">out</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span></span></span></span
            >. Add edge
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mo stretchy="false">(</mo
                      ><msub><mi>v</mi><mtext>in</mtext></msub
                      ><mo separator="true">,</mo
                      ><msub><mi>v</mi><mtext>out</mtext></msub
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      (v_\text{in}, v_\text{out})
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mopen">(</span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-c1a1c31017efdcea"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">in</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span
                  ><span class="mpunct">,</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord"
                    ><span class="mord mathnormal katex-83b7acfd98d6d4fd"
                      >v</span
                    ><span class="msupsub"
                      ><span class="vlist-t vlist-t2"
                        ><span class="vlist-r"
                          ><span class="vlist katex-3ebe6b8d14aeda59"
                            ><span class="katex-808d0e69bc40d2db"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord text mtight"
                                  ><span class="mord mtight">out</span></span
                                ></span
                              ></span
                            ></span
                          ><span class="vlist-s">​</span></span
                        ><span class="vlist-r"
                          ><span class="vlist katex-2506ec288336126a"
                            ><span></span></span></span></span></span></span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >
            with capacity
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow><mi>c</mi></mrow
                    ><annotation encoding="application/x-tex">
                      c
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-85c92d966084c2b4"></span
                  ><span class="mord mathnormal">c</span></span
                ></span
              ></span
            >.
          </p>
        </li>
        <li>
          <p>
            Multiple sources/sinks: make supersource connected to each source
            with infinite capacity and each sink connected to supersink with
            infinite capacity
          </p>
        </li>
      </ul>
      <a
        href="https://en.wikipedia.org/wiki/Push–relabel_maximum_flow_algorithm"
        >https://en.wikipedia.org/wiki/Push–relabel_maximum_flow_algorithm</a
      >
      <h4 id="matching__2">
        <a class="header-anchor" href="#matching__2">Matching</a>
      </h4>
      <p>Problems:</p>
      <a href="https://www.spoj.com/problems/MATCHING/"
        >https://www.spoj.com/problems/MATCHING/</a
      >
      <p>Notes:</p>
      <ul>
        <li>
          <p>
            Reduce into max flow by assigning each edge a capacity of 1, add
            source connected to each left vertex and sink connected to each
            right vertex.
          </p>
        </li>
      </ul>
      <h2 id="sorting"><a class="header-anchor" href="#sorting">Sorting</a></h2>
      <p>
        <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a> -
        <a href="https://pdfhost.io/v/E8BXkbbdN_mBIT_Advancedpdf.pdf"
          >Verification: MBIT Hen Hackers</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two</span>(<span class="hljs-params">l1: <span class="hljs-built_in">list</span>, l2: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Takes in two sorted lists and returns a sorted list. """</span>
    rtn = []
    p1 = p2 = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> p1 &lt; <span class="hljs-built_in">len</span>(l1) <span class="hljs-keyword">and</span> p2 &lt; <span class="hljs-built_in">len</span>(l2):
        <span class="hljs-keyword">if</span> l1[p1] &lt; l2[p2]:
            rtn.append(l1[p1])
            p1 += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            rtn.append(l2[p2])
            p2 += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> rtn + (l1[p1:] <span class="hljs-keyword">if</span> p1 != <span class="hljs-built_in">len</span>(l1) <span class="hljs-keyword">else</span> l2[p2:])

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Sorts a list. """</span>
    m = <span class="hljs-built_in">len</span>(l)&gt;&gt;<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> l <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> merge_two(merge_sort(l[:m]), merge_sort(l[m:]))</code></pre>
      <p>
        <a href="https://en.wikipedia.org/wiki/Quicksort">Quick Sort</a> -
        <a href="">Verification</a> - Complexity: expected
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">n1: <span class="hljs-built_in">int</span>, n2: <span class="hljs-built_in">int</span>, n3: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Finds the median of three numbers. """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([n1, n2, n3])[<span class="hljs-number">1</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Sorts a list. """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> l
    m = median(l[<span class="hljs-number">0</span>], l[<span class="hljs-built_in">len</span>(l)&gt;&gt;<span class="hljs-number">1</span>], l[-<span class="hljs-number">1</span>])
    l1, l2 = [], []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> l:
        (l1 <span class="hljs-keyword">if</span> n &lt; m <span class="hljs-keyword">else</span> \
        (l2 <span class="hljs-keyword">if</span> n &gt; m <span class="hljs-keyword">else</span> (l1 <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l1) &lt; <span class="hljs-built_in">len</span>(l2) <span class="hljs-keyword">else</span> l2))).append(n)
    <span class="hljs-keyword">return</span> quick_sort(l1) + quick_sort(l2)</code></pre>
      <p>
        <a
          href="https://activities.tjhsst.edu/computervision/lectures/kmeans_Handout.pdf#page=38"
          >Order statistics</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Splits the list by a particular value x. """</span>
    left, mid, right = [], [], []
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> l:
        (left <span class="hljs-keyword">if</span> v &lt; x <span class="hljs-keyword">else</span> (right <span class="hljs-keyword">if</span> v &gt; x <span class="hljs-keyword">else</span> mid)).append(v)
    <span class="hljs-keyword">return</span> left, mid, right

<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Returns the upper median of l, via a sort. """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(l)[<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">2</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Returns sorted(l)[i] in O(n) with median of medians as a pivot. """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) == <span class="hljs-number">1</span>: <span class="hljs-comment"># base case</span>
        <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>]
    medians = [median(l[<span class="hljs-number">5</span>*i: <span class="hljs-number">5</span>*(i + <span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-(-<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">5</span>))]
    left, mid, right = split(l, select(medians, <span class="hljs-built_in">len</span>(medians)//<span class="hljs-number">2</span>))
    k, m = <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(mid)
    <span class="hljs-keyword">if</span> k &lt;= i &lt;= k + m - <span class="hljs-number">1</span>: <span class="hljs-comment"># pivot is the answer</span>
        <span class="hljs-keyword">return</span> mid[<span class="hljs-number">0</span>]
    <span class="hljs-comment"># recur on sublist and get rid of pivot</span>
    <span class="hljs-keyword">return</span> select(left, i) <span class="hljs-keyword">if</span> i &lt; k <span class="hljs-keyword">else</span> select(right, i - k - m)</code></pre>
      <h2 id="data_structures">
        <a class="header-anchor" href="#data_structures">Data Structures</a>
      </h2>
      <h3 id="monotonic_query">
        <a class="header-anchor" href="#monotonic_query">Monotonic Query</a>
      </h3>
      <p>
        <a href="">Monotonic Queue</a> -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/220486/problem/A"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mn>1</mn><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(1)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord">1</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:
    <span class="hljs-string">""" O(1) append O(1) pop O(1) min query. """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, f=<span class="hljs-built_in">min</span></span>):
        self.stk, self.f = [], f

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stk)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"stack(<span class="hljs-subst">{self.stk}</span>)"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, val</span>):
        self.stk.append(
            (val, self.f(val, self.stk[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> val)
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.stk.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stk) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.stk[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"min() arg is an empty sequence"</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MinQueue</span>:
    <span class="hljs-string">"""
    O(1) append O(1) pop O(1) min

    Implemented via two min-stacks.
    """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, f=<span class="hljs-built_in">min</span></span>):
        self.instk, self.outstk = MinStack(f), MinStack(f)
        self.f = f

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.instk) + <span class="hljs-built_in">len</span>(self.outstk)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-string">"MinQueue"</span>:
        self.i, self.l = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.l == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">raise</span> StopIteration
        l = [self.outstk.stk, self.instk.stk][self.l]
        <span class="hljs-keyword">if</span> self.i == <span class="hljs-built_in">len</span>(l):
            self.l += <span class="hljs-number">1</span>
            self.i = <span class="hljs-number">0</span>
            <span class="hljs-keyword">return</span> self.__next__()
        v = l[<span class="hljs-built_in">len</span>(l) - <span class="hljs-number">1</span> - self.i] <span class="hljs-keyword">if</span> self.l == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> l[self.i]
        self.i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> v[<span class="hljs-number">0</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"queue(<span class="hljs-subst">{[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self]}</span>)"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, val</span>) -&gt; <span class="hljs-literal">None</span>:
        self.instk.append(val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">popleft</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.outstk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.instk) != <span class="hljs-number">0</span>:
                self.outstk.append(self.instk.pop())
        <span class="hljs-keyword">return</span> self.outstk.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appendleft</span>(<span class="hljs-params">self, val</span>) -&gt; <span class="hljs-literal">None</span>:
        self.outstk.append(val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.instk) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self.outstk) != <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.f(self.instk.<span class="hljs-built_in">min</span>(), self.outstk.<span class="hljs-built_in">min</span>())
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.instk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.outstk.<span class="hljs-built_in">min</span>()
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.outstk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.instk.<span class="hljs-built_in">min</span>()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"min() arg is an empty sequence"</span>)</code></pre>
      <h3 id="range_minimum_query">
        <a class="header-anchor" href="#range_minimum_query"
          >Range Minimum Query</a
        >
      </h3>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/00/Slides00.pdf"
          >Stanford lecture slides</a
        >
      </p>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/01/Slides01.pdf"
          >Fischer-Heun</a
        >
        -
        <a href="https://www.spoj.com/problems/RMQSQ/"
          >Verification: SPOJ RMQSQ</a
        >
        - Complexity: &lt;O(n), O(1)&gt;
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_number</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the Cartesian number for a given list. """</span>
    stk = []
    num = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>] &gt; l[i]:
            stk.pop()
            num &lt;&lt;= <span class="hljs-number">1</span>
        stk.append(l[i])
        num &lt;&lt;= <span class="hljs-number">1</span>
        num |= <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> num &lt;&lt; (<span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(l) - msb(num) - <span class="hljs-number">1</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">msb</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the index of the most significant bit of n. """</span>
    <span class="hljs-keyword">return</span> n.bit_length() - <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sparse_table</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes a sparse table (think 2^n jump pointers) """</span>
    n, m = <span class="hljs-built_in">len</span>(l), math.ceil(math.log2(<span class="hljs-built_in">len</span>(l)))
    dp = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i].append(i)

    k = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">if</span> i + k &gt;= n <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(dp[i + k]):
                <span class="hljs-keyword">break</span>
            <span class="hljs-comment"># min with lambdas is REALLY slow</span>
            <span class="hljs-comment"># dp[i].append(min(dp[i][j], dp[i + k][j], key=lambda x: l[x]))</span>
            dp[i].append(
                dp[i][j] <span class="hljs-keyword">if</span> l[dp[i][j]] &lt;= l[dp[i + k][j]] <span class="hljs-keyword">else</span> dp[i + k][j]
            )
        k &lt;&lt;= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sparse_rmq</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, table: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" Returns the index of the minimum element between i and j. """</span>
    k = msb(j - i + <span class="hljs-number">1</span>)
    <span class="hljs-comment"># return min(table[i][k], table[j - (1 &lt;&lt; k) + 1][k], key=lambda x: l[x])</span>
    <span class="hljs-keyword">return</span> table[i][k] <span class="hljs-keyword">if</span> l[table[i][k]] &lt; l[table[j - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]] <span class="hljs-keyword">else</span> \
           table[j - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">full_table</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Computes all possible ranges. """</span>
    n = <span class="hljs-built_in">len</span>(l)
    dp = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i].append(i)

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i + j &gt;= n <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(dp[i + <span class="hljs-number">1</span>]):
                <span class="hljs-keyword">break</span>
            <span class="hljs-comment"># dp[i].append(min(dp[i][j], dp[i + 1][j], key=lambda x: l[x]))</span>
            dp[i].append(
                dp[i][j] <span class="hljs-keyword">if</span> l[dp[i][j]] &lt;= l[dp[i + <span class="hljs-number">1</span>][j]] <span class="hljs-keyword">else</span> dp[i + <span class="hljs-number">1</span>][j]
            )

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">full_rmq</span>(<span class="hljs-params">table: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" O(1) RMQ. """</span>
    <span class="hljs-keyword">return</span> table[i][j - i]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fischer_heun</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Constructs the structure in O(n). """</span>
    b = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">int</span>(math.log2(<span class="hljs-built_in">len</span>(l))) &gt;&gt; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># k = 1, not k = 1/2 (&gt;&gt; 2 for 1/2)</span>
    blocks = [l[i: i + b] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(l), b)]
    a = [<span class="hljs-built_in">min</span>(block) <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]
    indexes = [<span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">min</span>(i + b, <span class="hljs-built_in">len</span>(l))), key=<span class="hljs-keyword">lambda</span> x: l[x])
               <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(l), b)]
    table = sparse_table(a)
    ids = [cartesian_number(block) <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]

    tables = {}
    <span class="hljs-keyword">for</span> i, block <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(blocks):
        <span class="hljs-keyword">if</span> ids[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> tables:
            tables[ids[i]] = full_table(block)

    <span class="hljs-keyword">return</span> b, a, indexes, ids, table, tables

<span class="hljs-keyword">def</span> <span class="hljs-title function_">rmq</span>(<span class="hljs-params">o: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span>, indexes: <span class="hljs-built_in">list</span>, ids: <span class="hljs-built_in">list</span>,
        table: <span class="hljs-built_in">list</span>, tables: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">""" O(1) RMQ. """</span>
    <span class="hljs-keyword">if</span> i &gt; j:
        i, j = j, i
    l, r = i//b, j//b         <span class="hljs-comment"># block indexes</span>
    li, ri = i - l*b, j - r*b <span class="hljs-comment"># index in the block</span>
    <span class="hljs-comment"># in same block</span>
    <span class="hljs-keyword">if</span> l == r:
        <span class="hljs-keyword">return</span> b*l + full_rmq(tables[ids[l]], li, ri)
    i1 = b*l + full_rmq(tables[ids[l]], li, b - <span class="hljs-number">1</span>)
    i2 = indexes[sparse_rmq(a, table, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>)] <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= l + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
    i3 = b*r + full_rmq(tables[ids[r]], <span class="hljs-number">0</span>, ri)

    v = i1 <span class="hljs-keyword">if</span> o[i1] &lt; o[i3] <span class="hljs-keyword">else</span> i3
    <span class="hljs-keyword">return</span> v <span class="hljs-keyword">if</span> i2 == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> o[v] &lt; o[i2] <span class="hljs-keyword">else</span> i2</code></pre>
      <h3 id="trees"><a class="header-anchor" href="#trees">Trees</a></h3>
      <h4 id="binary_indexed_trees_bits">
        <a class="header-anchor" href="#binary_indexed_trees_bits"
          >Binary Indexed Trees (BITS)</a
        >
      </h4>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_01_Binary_Index_Trees.pdf"
          >Binary Indexed Trees</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        construction,
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        query
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            self.l = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(n) + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n)):
                self.update(i, n[i])
        <span class="hljs-keyword">else</span>:
            self.l = [<span class="hljs-number">0</span>]*(n + <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.l)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-string">""" sum of elements up to (and including) i """</span>
        i += <span class="hljs-number">1</span>
        ans = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span>:
            ans += self.l[i]
            i -= (i &amp; -i)
        <span class="hljs-keyword">return</span> ans

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">range</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-string">""" sum of elements between i and j, inclusive on both ends """</span>
        <span class="hljs-keyword">return</span> self.query(j) - (self.query(i - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.l):
            self.l[i] += v
            i += (i &amp; -i)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RBIT</span>:

    <span class="hljs-string">""" BITs with range update. """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        p = <span class="hljs-built_in">len</span>(n) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">else</span> n
        self.t1, self.t2 = BIT(p), BIT(p)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):
                self.update(i, i, n[i])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.t1}</span> <span class="hljs-subst">{self.t2}</span>"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> i*self.t1.query(i) + self.t2.query(i)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">range</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> self.query(j) - (self.query(i - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.t1.update(i, v)
        self.t1.update(j + <span class="hljs-number">1</span>, -v)
        self.t2.update(i, -(i - <span class="hljs-number">1</span>)*v)
        self.t2.update(j + <span class="hljs-number">1</span>, j*v)</code></pre>
      <h4 id="segment_tree">
        <a class="header-anchor" href="#segment_tree">Segment Tree</a>
      </h4>
      <p>
        <a
          href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_15_Segment_Trees.pdf"
          >Segment Tree</a
        >
        - <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        construction,
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        query
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            self.l = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(n)&lt;&lt;<span class="hljs-number">2</span>)
            self.build(n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(n) - <span class="hljs-number">1</span>)
            self.n = <span class="hljs-built_in">len</span>(n)
        <span class="hljs-keyword">else</span>:
            self.l = [<span class="hljs-number">0</span>]*(n&lt;&lt;<span class="hljs-number">2</span>)
            self.n = n
        self.lazy = [<span class="hljs-number">0</span>]*(self.n&lt;&lt;<span class="hljs-number">2</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.l)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">list</span>, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># leaf</span>
        <span class="hljs-keyword">if</span> l == r:
            self.l[p] = a[l]
        <span class="hljs-keyword">else</span>:
            pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
            m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
            self.build(a, pl, l, m)
            self.build(a, pr, m + <span class="hljs-number">1</span>, r)
            self.l[p] = self.l[pl] + self.l[pr]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>):
        <span class="hljs-string">""" Propagate lazy values """</span>
        pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
        <span class="hljs-comment"># update the actual value proportional</span>
        <span class="hljs-comment"># to the number of elements in the range</span>
        self.l[p] += (r - l + <span class="hljs-number">1</span>)*self.lazy[p]
        <span class="hljs-comment"># not leaf</span>
        <span class="hljs-keyword">if</span> l != r:
            self.lazy[pl] += self.lazy[p]
            self.lazy[pr] += self.lazy[p]
        self.lazy[p] = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> self.subquery(i, j, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, self.n - <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subquery</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-comment"># segment outside query</span>
        <span class="hljs-keyword">if</span> i &gt; r <span class="hljs-keyword">or</span> j &lt; l:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        self.push(p, l, r)
        <span class="hljs-comment"># segment inside query</span>
        <span class="hljs-keyword">if</span> i &lt;= l <span class="hljs-keyword">and</span> r &lt;= j:
            <span class="hljs-keyword">return</span> self.l[p]
        <span class="hljs-comment"># partial</span>
        pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
        m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
        vl = self.subquery(i, j, pl, l, m)
        vr = self.subquery(i, j, pr, m + <span class="hljs-number">1</span>, r)
        <span class="hljs-keyword">return</span> (vl + vr)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.subupdate(i, j, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, self.n - <span class="hljs-number">1</span>, v)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subupdate</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>,
                  l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> i &gt; r <span class="hljs-keyword">or</span> j &lt; l:
            <span class="hljs-keyword">return</span>
        self.push(p, l, r)
        <span class="hljs-keyword">if</span> i &lt;= l <span class="hljs-keyword">and</span> r &lt;= j:
            self.lazy[p] += v
            self.push(p, l, r)
        <span class="hljs-keyword">else</span>:
            pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
            m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
            self.subupdate(i, j, pl, l, m, v)
            self.subupdate(i, j, pr, m + <span class="hljs-number">1</span>, r, v)
            self.l[p] = self.l[pl] + self.l[pr]</code></pre>
      <h4 id="avl_tree">
        <a class="header-anchor" href="#avl_tree">AVL Tree</a>
      </h4>
      <p>
        <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a> -
        <a href="">Verification</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        construction,
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(\log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
        query
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span>, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):
        self.key = key
        self.value = value
        self.parent = parent
        self.child = [left, right]
        self.balance = <span class="hljs-number">0</span>
        self.height = <span class="hljs-number">1</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.key}</span>:<span class="hljs-subst">{self.value}</span>:<span class="hljs-subst">{self.balance}</span>"</span> \
            <span class="hljs-keyword">if</span> self.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">str</span>(self.key)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extrema</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>):
        n = self
        <span class="hljs-keyword">while</span> n.child[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            n = n.child[i]
        <span class="hljs-keyword">return</span> n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.extrema(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.extrema(<span class="hljs-number">1</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.root = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">""</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self.root
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> s
        s = self.__str__(n.child[<span class="hljs-number">0</span>], s, d + <span class="hljs-number">1</span>)
        s += <span class="hljs-string">" "</span>*<span class="hljs-number">4</span>*d + <span class="hljs-built_in">str</span>(n) + <span class="hljs-string">"\n"</span>
        s = self.__str__(n.child[<span class="hljs-number">1</span>], s, d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> s

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-comment"># future: OS tree (302 in introduction to algorithms)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> self.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.root.<span class="hljs-built_in">min</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.root.<span class="hljs-built_in">max</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">if</span> self.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.root = Node(key, value)
            <span class="hljs-keyword">return</span>
        self.subadd(key, value, self.root)

        n = self.find(key, value)
        self.trace_heights(n)
        self.trace(n)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">return</span> self.subfind(key, value, self.root)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">contains</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> self.find(key, value) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        n = self.find(key, value)
        <span class="hljs-comment"># leaf node</span>
        <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-comment"># root node</span>
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, <span class="hljs-literal">None</span>)
            to_trace = n.parent
        <span class="hljs-keyword">elif</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = n.child[<span class="hljs-number">1</span>]
                self.root.parent = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, n.child[<span class="hljs-number">1</span>])
            to_trace = n.child[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">elif</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = n.child[<span class="hljs-number">0</span>]
                self.root.parent = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, n.child[<span class="hljs-number">0</span>])
            to_trace = n.child[<span class="hljs-number">0</span>]
        <span class="hljs-comment"># two children</span>
        <span class="hljs-keyword">else</span>:
            temp = n.child[<span class="hljs-number">0</span>].<span class="hljs-built_in">max</span>()
            n.key, n.value = temp.key, temp.value
            self.set_children(temp.parent, temp.key, temp.child[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">if</span> temp.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                self.trace_heights(temp.child[<span class="hljs-number">0</span>])
            self.trace_heights(temp)
            <span class="hljs-keyword">return</span>

        self.trace_heights(to_trace)
        self.trace(to_trace)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, key, value, new</span>):
        self.delete(key, value)
        self.add(new, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        n = self.<span class="hljs-built_in">min</span>()
        self.delete(n.key, n.value)
        <span class="hljs-keyword">return</span> n.key, n.value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_children</span>(<span class="hljs-params">self, n, key, value</span>):
        n.child[key &gt; n.key] = value
        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            value.parent = n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subadd</span>(<span class="hljs-params">self, key, value, n</span>):
        <span class="hljs-keyword">if</span> n.child[key &gt; n.key] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            n.child[key &gt; n.key] = Node(key, value, n)
            <span class="hljs-keyword">return</span>
        self.subadd(key, value, n.child[key &gt; n.key])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subfind</span>(<span class="hljs-params">self, key, value, n</span>):
        <span class="hljs-keyword">if</span> key == n.key <span class="hljs-keyword">and</span> value == n.value:
            <span class="hljs-keyword">return</span> n

        <span class="hljs-keyword">if</span> n.child[key &gt; n.key] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        <span class="hljs-keyword">return</span> self.subfind(key, value, n.child[key &gt; n.key])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trace_heights</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-keyword">while</span> n <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.update_height(n)
            n = n.parent

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_height</span>(<span class="hljs-params">self, n</span>):
        left  = n.child[<span class="hljs-number">0</span>].height <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        right = n.child[<span class="hljs-number">1</span>].height <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        n.height = <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>
        n.balance = right - left

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-keyword">while</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            p = n.parent
            <span class="hljs-comment"># right child</span>
            <span class="hljs-keyword">if</span> n.key &gt; p.key:
                <span class="hljs-keyword">if</span> p.balance == <span class="hljs-number">2</span>:
                    (self.rotate_right_left <span class="hljs-keyword">if</span> n.balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
                     self.rotate_left)(p, n)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> p.balance == -<span class="hljs-number">2</span>:
                    (self.rotate_left_right <span class="hljs-keyword">if</span> n.balance &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
                     self.rotate_right)(p, n)
            n = p

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, p, n, d</span>):
        c = n.child[d]
        p.child[d ^ <span class="hljs-number">1</span>] = c

        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            c.parent = p
        n.child[d] = p

        n.parent = p.parent
        <span class="hljs-keyword">if</span> p.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            p.parent.child[p.key &gt; p.parent.key] = n
        <span class="hljs-keyword">else</span>:
            self.root = n
        p.parent = n

        <span class="hljs-comment"># order matters: update from the bottom up</span>
        self.update_height(p)
        self.update_height(n)

        <span class="hljs-keyword">return</span> n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_left</span>(<span class="hljs-params">self, p, n</span>): <span class="hljs-keyword">return</span> self.rotate(p, n, <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_right</span>(<span class="hljs-params">self, p, n</span>): <span class="hljs-keyword">return</span> self.rotate(p, n, <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_left_right</span>(<span class="hljs-params">self, p, n</span>):
        <span class="hljs-keyword">return</span> self.rotate_right(p, self.rotate_left(n, n.child[<span class="hljs-number">1</span>]))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_right_left</span>(<span class="hljs-params">self, p, n</span>):
        <span class="hljs-keyword">return</span> self.rotate_left(p, self.rotate_right(n, n.child[<span class="hljs-number">0</span>]))</code></pre>
      <h4 id="cartesian_tree">
        <a class="header-anchor" href="#cartesian_tree">Cartesian Tree</a>
      </h4>
      <p>
        <a href="http://web.stanford.edu/class/cs166/lectures/01/Slides01.pdf"
          >Cartesian Tree</a
        >
        -
        <a href="https://www.spoj.com/problems/RMQSQ/"
          >Verification: SPOJ RMQSQ</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CartesianTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):
        self.key = key
        self.parent = parent
        self.child = [left, right]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">""</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> s
        s = self.__str__(n.child[<span class="hljs-number">0</span>], s, d + <span class="hljs-number">1</span>)
        s += <span class="hljs-string">" "</span>*<span class="hljs-number">4</span>*d + <span class="hljs-built_in">str</span>(n.key) + <span class="hljs-string">"\n"</span>
        s = self.__str__(n.child[<span class="hljs-number">1</span>], s, d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> s

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_tree</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; CartesianTree:
    <span class="hljs-string">""" Constructs a Cartesian tree for a given list in O(n). """</span>
    stk = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        c = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>].key &gt; l[i]:
            c = stk.pop()
        stk.append(CartesianTree(l[i], stk[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, c))
        <span class="hljs-comment"># add right child</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">1</span>:
            stk[-<span class="hljs-number">2</span>].child[<span class="hljs-number">1</span>] = stk[-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">return</span> stk[<span class="hljs-number">0</span>]</code></pre>
      <h4 id="kd-tree"><a class="header-anchor" href="#kd-tree">kd-Tree</a></h4>
      <p>
        <a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf"
          >CMU lecture slides</a
        >
      </p>
      <p>
        <a
          href="https://activities.tjhsst.edu/computervision/lectures/kmeans_Handout.pdf"
          >kd-Tree</a
        >
        - <a href="">Verification</a> - Complexity:
      </p>
      <ul>
        <li>
          <p>
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                      ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      \mathcal{O}(n \log n)
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mord mathcal katex-41b20525125e978b">O</span
                  ><span class="mopen">(</span
                  ><span class="mord mathnormal">n</span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mop"
                    >lo<span class="katex-8f508bf653d98452">g</span></span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal">n</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >
            construction
          </p>
        </li>
        <li>
          <p>
            <span class="katex"
              ><span class="katex-mathml"
                ><math xmlns="http://www.w3.org/1998/Math/MathML"
                  ><semantics
                    ><mrow
                      ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                      ><msup><mn>2</mn><mi>d</mi></msup
                      ><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>n</mi
                      ><mo stretchy="false">)</mo></mrow
                    ><annotation encoding="application/x-tex">
                      \mathcal{O}(2^d + \log n)
                    </annotation></semantics
                  ></math
                ></span
              ><span aria-hidden="true" class="katex-html"
                ><span class="base"
                  ><span class="strut katex-21a89b88fe388337"></span
                  ><span class="mord mathcal katex-41b20525125e978b">O</span
                  ><span class="mopen">(</span
                  ><span class="mord"
                    ><span class="mord">2</span
                    ><span class="msupsub"
                      ><span class="vlist-t"
                        ><span class="vlist-r"
                          ><span class="vlist katex-1d2aad06aa17d668"
                            ><span class="katex-00abc151c90866a2"
                              ><span
                                class="pstrut katex-1527d00b389b9857"
                              ></span
                              ><span class="sizing reset-size6 size3 mtight"
                                ><span class="mord mathnormal mtight"
                                  >d</span
                                ></span
                              ></span
                            ></span
                          ></span
                        ></span
                      ></span
                    ></span
                  ><span class="mspace katex-74dc427d3e42f308"></span
                  ><span class="mbin">+</span
                  ><span class="mspace katex-74dc427d3e42f308"></span></span
                ><span class="base"
                  ><span class="strut katex-fc02a23bcdeac7fb"></span
                  ><span class="mop"
                    >lo<span class="katex-8f508bf653d98452">g</span></span
                  ><span class="mspace katex-d9c1af4877255043"></span
                  ><span class="mord mathnormal">n</span
                  ><span class="mclose">)</span></span
                ></span
              ></span
            >
            nearest neighbor query
          </p>
        </li>
      </ul>
      <pre><code class="python hljs"><span class="hljs-comment">### median selection</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select_split</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Splits the list by a particular value x. """</span>
    left, mid, right = [], [], []
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> l:
        (left <span class="hljs-keyword">if</span> v &lt; x <span class="hljs-keyword">else</span> (right <span class="hljs-keyword">if</span> v &gt; x <span class="hljs-keyword">else</span> mid)).append(v)
    <span class="hljs-keyword">return</span> left, mid, right

<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Returns the upper median of l, via a sort. """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(l)[<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">2</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Returns sorted(l)[i] in O(n) with median of medians as a pivot. """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) == <span class="hljs-number">1</span>: <span class="hljs-comment"># base case</span>
        <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>]
    medians = [median(l[<span class="hljs-number">5</span>*i: <span class="hljs-number">5</span>*(i + <span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-(-<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">5</span>))]
    left, mid, right = select_split(l, select(medians, <span class="hljs-built_in">len</span>(medians)//<span class="hljs-number">2</span>))
    k, m = <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(mid)
    <span class="hljs-keyword">if</span> k &lt;= i &lt;= k + m - <span class="hljs-number">1</span>: <span class="hljs-comment"># pivot is the answer</span>
        <span class="hljs-keyword">return</span> mid[<span class="hljs-number">0</span>]
    <span class="hljs-comment"># recur on sublist and get rid of pivot</span>
    <span class="hljs-keyword">return</span> select(left, i) <span class="hljs-keyword">if</span> i &lt; k <span class="hljs-keyword">else</span> select(right, i - k - m)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">split_median</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Picks the point which is the median along the dimension cd. """</span>
    m = select([point[cd] <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points], <span class="hljs-built_in">len</span>(points)//<span class="hljs-number">2</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):
        <span class="hljs-keyword">if</span> points[i][cd] == m: <span class="hljs-comment"># pick any point with value m</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> points[i], points[:i] + points[i + <span class="hljs-number">1</span>:]

<span class="hljs-comment">### helper methods</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Squared distance between two points."""</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>((p1[i] - p2[i])*(p1[i] - p2[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p1)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">closest</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, q: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Returns the point closest to q in points (nearest neighbor query). """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(points, key=<span class="hljs-keyword">lambda</span> p: dist(p, q))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">distbb</span>(<span class="hljs-params">p: <span class="hljs-built_in">tuple</span>, bb: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Squared distance between a point and a bounding box. """</span>
    <span class="hljs-comment"># three cases, use x if x is in the box, otherwise one of the bounds</span>
    bbp = <span class="hljs-built_in">tuple</span>(box[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> x &lt; box[<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> (box[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> x &gt; box[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> x)
                <span class="hljs-keyword">for</span> x, box <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(p, bb))
    <span class="hljs-keyword">return</span> dist(p, bbp)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">trimbb</span>(<span class="hljs-params">bb: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Trims the bounding box by the plane x_cd = p[cd]. """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bb) == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> bb
    bb = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">list</span>(box) <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> bb) <span class="hljs-comment"># copy</span>
    bb[cd][<span class="hljs-number">1</span> - d] = p[cd]              <span class="hljs-comment"># update, assuming p[cd] is valid</span>
    <span class="hljs-keyword">return</span> bb

<span class="hljs-comment">### kd-tree</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">""" Splits the list of points by the plane x_cd = p[cd]. """</span>
    left, right = [], []
    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:
        <span class="hljs-comment"># add point with the same value as p at cd to the right side</span>
        (left <span class="hljs-keyword">if</span> point[cd] &lt; p[cd] <span class="hljs-keyword">else</span> right).append(point)
    <span class="hljs-keyword">return</span> left, right

<span class="hljs-keyword">class</span> <span class="hljs-title class_">kdNode</span>:

    <span class="hljs-string">""" kd-tree node. """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, point: <span class="hljs-built_in">tuple</span>=<span class="hljs-literal">None</span>, cd: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.child, self.point, self.cd, self.bb = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>], point, cd, []
        self.D, self.tight_bb = <span class="hljs-built_in">len</span>(point) <span class="hljs-keyword">if</span> point <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n: <span class="hljs-string">"kdNode"</span>=<span class="hljs-literal">None</span>, d: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">""" Fancy string representation. """</span>
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self <span class="hljs-comment"># called with None by defualt, set to the root</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> [] <span class="hljs-comment"># leaf node</span>
        s = [<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">' '</span>*<span class="hljs-number">4</span>*d}</span><span class="hljs-subst">{n.point}</span>"</span>]
        s += self.__str__(n.child[<span class="hljs-number">0</span>], d + <span class="hljs-number">1</span>)
        s += self.__str__(n.child[<span class="hljs-number">1</span>], d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\n"</span>.join(s) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> s

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dir</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">""" Gets the proper left/right child depending on the point. """</span>
        <span class="hljs-keyword">return</span> p[self.cd] &gt;= self.point[self.cd]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tighten</span>(<span class="hljs-params">self, t: <span class="hljs-string">"KdNode"</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">""" Tighten bounding boxes in O(nd). """</span>
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: t = self <span class="hljs-comment"># called with None, set to the root</span>
        l, r, t.tight_bb = t.child[<span class="hljs-number">0</span>], t.child[<span class="hljs-number">1</span>], <span class="hljs-literal">True</span>
        <span class="hljs-comment"># recur on children</span>
        <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: self.tighten(l)
        <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: self.tighten(r)
        <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># leaf node, box is just the singular point</span>
            t.bb = [(t.point[d], t.point[d]) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t.D)]
        <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># one child, inherit box of child</span>
            t.bb = l.bb <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> r.bb
            t.bb = [(<span class="hljs-built_in">min</span>(box[<span class="hljs-number">0</span>], v), <span class="hljs-built_in">max</span>(box[<span class="hljs-number">1</span>], v))  <span class="hljs-comment"># add node's point</span>
                    <span class="hljs-keyword">for</span> box, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(t.bb, t.point)]
        <span class="hljs-keyword">else</span>:                        <span class="hljs-comment"># two children, combine boxes</span>
            t.bb = [(<span class="hljs-built_in">min</span>(bbl[<span class="hljs-number">0</span>], bbr[<span class="hljs-number">0</span>], v), <span class="hljs-built_in">max</span>(bbl[<span class="hljs-number">1</span>], bbr[<span class="hljs-number">1</span>], v))
                    <span class="hljs-keyword">for</span> bbl, bbr, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(l.bb, r.bb, t.point)]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add</span>(<span class="hljs-params">self, t: <span class="hljs-string">"kdNode"</span>, p: <span class="hljs-built_in">tuple</span>, parent: <span class="hljs-string">"kdNode"</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">""" Insert the given point into the tree. """</span>
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:      <span class="hljs-comment"># found leaf to insert new node in</span>
            t = kdNode(p, (parent.cd + <span class="hljs-number">1</span>) % parent.D)
        <span class="hljs-keyword">elif</span> t.point == p: <span class="hljs-comment"># ignore duplicates</span>
            <span class="hljs-keyword">return</span> t
        <span class="hljs-keyword">else</span>:              <span class="hljs-comment"># update pointers</span>
            t.child[t.<span class="hljs-built_in">dir</span>(p)] = self.__add(t.child[t.<span class="hljs-built_in">dir</span>(p)], p, t)
            t.tight_bb = <span class="hljs-literal">False</span> <span class="hljs-comment"># no longer use tight bounding boxes</span>
            <span class="hljs-comment"># is it worth O(d log n) instead of O(log n) for tighter boxes?</span>
            <span class="hljs-comment"># if so, manually update t.bb over each of the d dimensions</span>
        <span class="hljs-keyword">return</span> t

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">""" Wrapper over the recursive helper function __add. """</span>
        <span class="hljs-keyword">if</span> self.point <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># empty tree, simply change our own point</span>
            self.__init__(p)
        self.__add(self, p)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__closest</span>(<span class="hljs-params">self, t: <span class="hljs-string">"kdNode"</span>, p: <span class="hljs-built_in">tuple</span>, curr_bb: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">""" Returns the closest point to p in the tree (nearest neighbor). """</span>
        <span class="hljs-comment"># all points in this bounding box farther than existing point</span>
        bb = t.bb <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> t.tight_bb <span class="hljs-keyword">else</span> curr_bb
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> distbb(p, bb) &gt; self.best_dist:
            <span class="hljs-keyword">return</span>
        <span class="hljs-comment"># update best point</span>
        d = dist(p, t.point)
        <span class="hljs-keyword">if</span> d &lt; self.best_dist:
            self.best, self.best_dist = t.point, d
        <span class="hljs-comment"># visit subtrees in order of distance from p</span>
        i, j = t.<span class="hljs-built_in">dir</span>(p), <span class="hljs-number">1</span> - t.<span class="hljs-built_in">dir</span>(p)
        self.__closest(t.child[i], p, trimbb(curr_bb, t.cd, t.point, i))
        self.__closest(t.child[j], p, trimbb(curr_bb, t.cd, t.point, j))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closest</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">""" Wrapper over the recursive helper function __closest. """</span>
        self.best, self.best_dist = <span class="hljs-literal">None</span>, <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)
        bb = [[-<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p))]
        self.__closest(self, p, [] <span class="hljs-keyword">if</span> self.tight_bb <span class="hljs-keyword">else</span> bb)
        <span class="hljs-keyword">return</span> self.best

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nnsearch</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span>, r: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">""" Finds the points that are within a radius of r from p. """</span>
        l = []
        h = [(<span class="hljs-number">0</span>, self)]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(h) &gt; <span class="hljs-number">0</span>:
            d, n = heapq.heappop(h)
            <span class="hljs-keyword">if</span> d &gt; r*r: <span class="hljs-comment"># stop processing if out of circle</span>
                <span class="hljs-keyword">return</span> l
            <span class="hljs-keyword">if</span> is_leaf(n):
                l.append(n.point)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.child + [kdNode(n.point)]:
                    <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                        d = dist(p, child.point) <span class="hljs-keyword">if</span> is_leaf(child) <span class="hljs-keyword">else</span> \
                            distbb(p, child.bb)
                        heapq.heappush(h, (d, child))
        <span class="hljs-keyword">return</span> l

<span class="hljs-keyword">class</span> <span class="hljs-title class_">kdTree</span>(<span class="hljs-title class_ inherited__">kdNode</span>):

    <span class="hljs-string">""" Thin wrapper over a kd-node to build a tree from a list of points.  """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, points: <span class="hljs-built_in">list</span>=[]</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-comment"># no need for duplicate points</span>
            self.__build_tree(self, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(points)))
            self.tighten()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__build_tree</span>(<span class="hljs-params">self, t: kdNode, points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; kdNode:
        <span class="hljs-string">""" Constructs a kd-tree in O(n log n). """</span>
        N, D, t.cd = <span class="hljs-built_in">len</span>(points), <span class="hljs-built_in">len</span>(points[<span class="hljs-number">0</span>]), cd
        t.point, points = split_median(points, cd) <span class="hljs-comment"># median</span>
        t.D, next_cd = D, (cd + <span class="hljs-number">1</span>) % D
        t.child = [self.__build_tree(kdNode(), l, next_cd) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) &gt; <span class="hljs-number">0</span>
                   <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> split(points, cd, t.point)]
        <span class="hljs-keyword">return</span> t</code></pre>
      <h3 id="prefix_sums">
        <a class="header-anchor" href="#prefix_sums">Prefix Sums</a>
      </h3>
      <p>
        <a href="">1D Prefix Sums</a> -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/C"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">i, j</span>):
    <span class="hljs-keyword">return</span> prefix[j + <span class="hljs-number">1</span>] - prefix[i]

prefix = [<span class="hljs-number">0</span>]*(N + <span class="hljs-number">1</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    prefix[i + <span class="hljs-number">1</span>] = prefix[i] + a[i]</code></pre>
      <p>
        <a href="">2D Prefix Sums</a> -
        <a
          href="https://codeforces.com/group/M4wsRWBHyZ/contest/232015/problem/D"
          >Verification</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(nm)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span
              ><span class="mord mathnormal">nm</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">prefix, x1, y1, x2, y2</span>):
    <span class="hljs-keyword">return</span> prefix[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] - prefix[x2 + <span class="hljs-number">1</span>][y1] - prefix[x1][y2 + <span class="hljs-number">1</span>] + \
           prefix[x1][y1]

prefix = [[<span class="hljs-number">0</span>]*(M + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N + <span class="hljs-number">1</span>)]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix[<span class="hljs-number">0</span>])):
        prefix[i][j] = prefix[i - <span class="hljs-number">1</span>][j] + m[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prefix)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix[<span class="hljs-number">0</span>])):
        prefix[i][j] = prefix[i][j - <span class="hljs-number">1</span>]</code></pre>
      <h2 id="computational_geometry">
        <a class="header-anchor" href="#computational_geometry"
          >Computational Geometry</a
        >
      </h2>
      <p>Helper methods</p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">""" Squared l2 distance between the points p1 and p2. """</span>
    (x1, y1), (x2, y2) = p1, p2
    <span class="hljs-keyword">return</span> ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ccw</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span>, p3: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">""" Whether (p1, p2, p3) forms a counterclockwise turn.
    &gt; 0 counterclockwise, = 0 collinear, and &lt; 0 clockwise. """</span>
    (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3
    <span class="hljs-comment"># this is reasonably numerically stable, no need to check &gt; EPS</span>
    <span class="hljs-keyword">return</span> (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)</code></pre>
      <h3 id="closest_pair">
        <a class="header-anchor" href="#closest_pair">Closest Pair</a>
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Closest_pair_of_points_problem"
          >Closest pair</a
        >
        - <a href="">Verification: CV</a> - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">slow_closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    best = <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):
            <span class="hljs-keyword">if</span> dist(points[i], points[j]) &lt; best:
                best, p1, p2 = dist(points[i], points[j]), points[i], points[j]
    <span class="hljs-keyword">return</span> p1, p2

<span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">return</span> [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>] &lt;= x], [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>] &gt; x]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, X: <span class="hljs-built_in">list</span>, Y: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &lt;= <span class="hljs-number">3</span>:
        <span class="hljs-keyword">return</span> slow_closest_pair(points)

    mid = <span class="hljs-built_in">len</span>(X)//<span class="hljs-number">2</span>
    x = (X[mid][<span class="hljs-number">0</span>] + X[mid - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(X) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> X[mid][<span class="hljs-number">0</span>]
    pointsl, pointsr = divide(points, x)
    Xl, Xr = divide(X, x)
    Yl, Yr = divide(Y, x)

    l1, l2 = recur_closest_pair(pointsl, Xl, Yl)
    r1, r2 = recur_closest_pair(pointsr, Xr, Yr)

    dl, dr = dist(l1, l2), dist(*r1, *r2)
    d = <span class="hljs-built_in">min</span>(dl, dr)

    dp = <span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>)
    Yp = [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> Y <span class="hljs-keyword">if</span> x - d &lt;= p[<span class="hljs-number">0</span>] &lt;= x + d]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Yp)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(i + <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(Yp))):
            <span class="hljs-keyword">if</span> dist(Yp[i], Yp[j]) &lt; dp:
                dp, m1, m2 = dist(Yp[i], Yp[j]), Yp[i],  Yp[j]

    <span class="hljs-keyword">if</span> dp &lt; d:
        <span class="hljs-keyword">return</span> m1, m2
    <span class="hljs-keyword">return</span> (l1, l2) <span class="hljs-keyword">if</span> dl &lt; dr <span class="hljs-keyword">else</span> (r1, r2)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">return</span> recur_closest_pair(points,
                              <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> p: p[<span class="hljs-number">0</span>]),
                              <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> p: p[<span class="hljs-number">1</span>]))</code></pre>
      <h3 id="convex_hull">
        <a class="header-anchor" href="#convex_hull">Convex Hull</a>
      </h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Graham_scan">Graham scan</a>,
        specifically
        <a
          href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain"
          >Andrew's Monotone Chain</a
        >
        -
        <a href="https://open.kattis.com/problems/convexhull"
          >Verification: Kattis convexhull</a
        >
        - Complexity:
        <span class="katex"
          ><span class="katex-mathml"
            ><math xmlns="http://www.w3.org/1998/Math/MathML"
              ><semantics
                ><mrow
                  ><mi mathvariant="script">O</mi><mo stretchy="false">(</mo
                  ><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi
                  ><mo stretchy="false">)</mo></mrow
                ><annotation encoding="application/x-tex">
                  \mathcal{O}(n \log n)
                </annotation></semantics
              ></math
            ></span
          ><span aria-hidden="true" class="katex-html"
            ><span class="base"
              ><span class="strut katex-fc02a23bcdeac7fb"></span
              ><span class="mord mathcal katex-41b20525125e978b">O</span
              ><span class="mopen">(</span><span class="mord mathnormal">n</span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mop"
                >lo<span class="katex-8f508bf653d98452">g</span></span
              ><span class="mspace katex-d9c1af4877255043"></span
              ><span class="mord mathnormal">n</span
              ><span class="mclose">)</span></span
            ></span
          ></span
        >
      </p>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convex_hull</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">""" Finds the convex hull of the point list. """</span>
    points = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(points))
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> points

    final = []
    <span class="hljs-keyword">for</span> half <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):
        hull = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ccw(hull[-<span class="hljs-number">2</span>], hull[-<span class="hljs-number">1</span>], p) &lt;= <span class="hljs-number">0</span>:
                hull.pop()
            hull.append(p)
        final += hull[:-<span class="hljs-number">1</span>]
        points = points[::-<span class="hljs-number">1</span>]

    <span class="hljs-keyword">return</span> final</code></pre>
      <h2 id="ad-hoc"><a class="header-anchor" href="#ad-hoc">Ad-hoc</a></h2>
      <h3 id="grid_bfs_problems">
        <a class="header-anchor" href="#grid_bfs_problems">Grid BFS Problems</a>
      </h3>
      <pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc</span>(<span class="hljs-params">i</span>): <span class="hljs-keyword">return</span> i//N, i % N

<span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid</span>(<span class="hljs-params">i, j</span>): <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= i &lt; M <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; N

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_children</span>(<span class="hljs-params">i, j</span>):
    <span class="hljs-keyword">return</span> [child <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> [(i + <span class="hljs-number">1</span>, j), (i - <span class="hljs-number">1</span>, j), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>)]
            <span class="hljs-keyword">if</span> is_valid(*child)]</code></pre>
      <div class="page-foot">
        さみしいも、たのしい。<a
          href="https://github.com/stephen-huan/cgdct.moe/blob/master/blog/algorithm-library.md"
          >Page source</a
        >. Last updated: <time datetime="2023-01-07T19:28:58">2023-01-07</time>.
        <!-- Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. -->
      </div>
    </div>
    <!-- CONTENT ENDS HERE -->
  </body>
</html>
