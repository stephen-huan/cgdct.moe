<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/atom-one-light.min.css">
 
  <link rel="stylesheet" href="/css/main.css">
  <link rel="icon" href="/assets/favicon.svg">
   <title>Algorithms for competitive programming</title> 
</head>
<body>
  <header>
  <div class="blog-name">
    
    <a href="/"><b class="font-weight-bold">Stephen</b> Huan</a>
    
  </div>
  <nav>
    <ul><li><a href="/" class="">about</a></li>
<li><a href="/blog/" class="">blog</a></li>
<li><a href="/projects/" class="">projects</a></li>
<li><a href="/publications/" class="">publications</a></li>
<li><a href="/assets/pdf/cv.pdf" class="">cv</a></li>
</ul>
    <img alt="menu icon" src="/assets/hamburger.svg"
     width="32" height="32" id="menu-icon">
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content">
<h1>Algorithms for competitive programming</h1>
<span class="post-meta"><time datetime="2019-12-07">2019-12-07</time></span><span class="post-tags">&nbsp; &middot;&nbsp; <a href="/tag/cs/"><b>#</b> cs</a></span>
<div class="franklin-toc"><ol><li><a href="#basics">Basics</a><ol><li><a href="#input">Input</a></li></ol></li><li><a href="#numerical_algorithms">Numerical Algorithms</a><ol><li><a href="#number_theory">Number Theory</a></li><li><a href="#binary">Binary</a></li><li><a href="#matrices">Matrices</a></li><li><a href="#linear_programming">Linear Programming</a></li><li><a href="#fast_fourier_transform">Fast Fourier Transform</a></li></ol></li><li><a href="#strings">Strings</a><ol><li><a href="#suffix_structures">Suffix Structures</a></li><li><a href="#matching">Matching</a></li></ol></li><li><a href="#dynamic_programming">Dynamic Programming</a><ol><li><a href="#memoization">Memoization</a></li></ol></li><li><a href="#graph_algorithms">Graph Algorithms</a><ol><li><a href="#traversals">Traversals</a></li><li><a href="#shortest_path">Shortest Path</a></li><li><a href="#union-find">Union-find</a></li><li><a href="#minimum_spanning_tree">Minimum Spanning Tree</a></li><li><a href="#connected_components">Connected Components</a></li><li><a href="#tree">Tree</a></li><li><a href="#flow">Flow</a></li></ol></li><li><a href="#sorting">Sorting</a></li><li><a href="#data_structures">Data Structures</a><ol><li><a href="#monotonic_query">Monotonic Query</a></li><li><a href="#range_minimum_query">Range Minimum Query</a></li><li><a href="#trees">Trees</a></li><li><a href="#prefix_sums">Prefix Sums</a></li></ol></li><li><a href="#computational_geometry">Computational Geometry</a><ol><li><a href="#closest_pair">Closest Pair</a></li><li><a href="#convex_hull">Convex Hull</a></li></ol></li><li><a href="#ad-hoc">Ad-hoc</a><ol><li><a href="#grid_bfs_problems">Grid BFS Problems</a></li></ol></li></ol></div>
<h2 id="basics"><a href="#basics" class="header-anchor">Basics</a></h2>
<p>Running: <code>python</code>.</p>
<p>Profiling: <code>python -m cProfile -s tottime</code>.</p>
<p>Fast execution: <a href="https://www.pypy.org/"><code>pypy</code></a>.</p>
<h3 id="input"><a href="#input" class="header-anchor">Input</a></h3>
<h4 id="usaco"><a href="#usaco" class="header-anchor">USACO</a></h4>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span>: sys.stdin.readline()[:-<span class="hljs-number">1</span>] <span class="hljs-comment"># fast cin</span>

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.in&quot;</span>) <span class="hljs-keyword">as</span> f:
    N = <span class="hljs-built_in">int</span>(f.readline())
    N, M = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split())
    l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split()))
    m = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line.split())) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
    f.write(<span class="hljs-built_in">str</span>(ans) + <span class="hljs-string">&quot;\n&quot;</span>)</code></pre>
<h4 id="fast_inputoutput"><a href="#fast_inputoutput" class="header-anchor">Fast input/output</a></h4>
<p><a href="https://www.spoj.com/problems/INTEST/">Verification: SPOJ INTEST</a>, <a href="https://www.spoj.com/problems/INOUTEST/">SPOJ INOUTEST</a>, testing with <a href="https://docs.python.org/3/library/timeit.html">timeit</a></p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = sys.stdin.readline <span class="hljs-comment"># fast cin</span>

__lines, __<span class="hljs-built_in">print</span> = [], <span class="hljs-built_in">print</span>
<span class="hljs-built_in">print</span> = <span class="hljs-keyword">lambda</span> s: __lines.append(s) <span class="hljs-comment"># fast cout</span>
cout = <span class="hljs-keyword">lambda</span>: __<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, __lines)))</code></pre>
<h4 id="codeforces"><a href="#codeforces" class="header-anchor">Codeforces</a></h4>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">input</span> = sys.stdin.readline <span class="hljs-comment"># fast cin</span>

N = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())
l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))</code></pre>
<h4 id="graphs"><a href="#graphs" class="header-anchor">Graphs</a></h4>
<h5 id="unweighted"><a href="#unweighted" class="header-anchor">Unweighted</a></h5>
<pre><code class="python hljs">graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x) - <span class="hljs-number">1</span>, f.readline().split())
    graph[a].append(b)
    graph[b].append(a)</code></pre>
<h5 id="weighted"><a href="#weighted" class="header-anchor">Weighted</a></h5>
<pre><code class="python hljs">graph = {i: {} <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, f.readline().split())
    a -= <span class="hljs-number">1</span>
    b -= <span class="hljs-number">1</span>
    <span class="hljs-comment"># will overwrite if same edge is repeated - pick min edge (usually)</span>
    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph[a] <span class="hljs-keyword">or</span> w &lt; graph[a][b]:
        graph[a][b] = w
    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph[b] <span class="hljs-keyword">or</span> w &lt; graph[b][a]:
        graph[b][a] = w</code></pre>
<h2 id="numerical_algorithms"><a href="#numerical_algorithms" class="header-anchor">Numerical Algorithms</a></h2>
<h3 id="number_theory"><a href="#number_theory" class="header-anchor">Number Theory</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log b) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>:
        a, b = b, a % b
    <span class="hljs-keyword">return</span> a

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>: <span class="hljs-keyword">return</span> (a//gcd(a, b))*b</code></pre>
<p>floor</p>
<pre><code class="python hljs">x//<span class="hljs-number">1</span></code></pre>
<p>ceiling</p>
<pre><code class="python hljs">-(-x//<span class="hljs-number">1</span>)</code></pre>
<h4 id="primes"><a href="#primes" class="header-anchor">Primes</a></h4>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prime</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">&quot;&quot;&quot; Checks whether a number is prime or not with trial divison. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n != <span class="hljs-number">2</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):
        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>
<p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/G">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sieve</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Generates a look up table of primality up to n. &quot;&quot;&quot;</span>
    l = [<span class="hljs-literal">True</span>]*(n + <span class="hljs-number">1</span>)
    l[<span class="hljs-number">0</span>] = l[<span class="hljs-number">1</span>] = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> l[i]:
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i*i, <span class="hljs-built_in">len</span>(l), i):
                l[j] = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> l</code></pre>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">primes</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Return a list of all primes less than or equal to n. &quot;&quot;&quot;</span>
    s = sieve(n)
    <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> s[i]]</code></pre>
<h4 id="modulo"><a href="#modulo" class="header-anchor">Modulo</a></h4>
<pre><code class="python hljs"><span class="hljs-comment"># common</span>
m = <span class="hljs-number">1000000007</span>

(a + b) % m == ((a % m) + (b % m)) % m
(a - b) % m == ((a % m) - (b % m)) % m
(a * b) % m == ((a % m) * (b % m)) % m</code></pre>
<p>tl;dr spam modulo if the problem asks you to return the answer mod <code>m</code>.</p>
<p>If asking for count &#40;which is often&#41; must be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> \geq 0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<pre><code class="python hljs">x <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x + m</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Modular_exponentiation">Modular exponentiation</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/E">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log e) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mod_exp</span>(<span class="hljs-params">b: <span class="hljs-built_in">int</span>, e: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns b^e % m &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    rtn = <span class="hljs-number">1</span>
    b %= m
    <span class="hljs-keyword">while</span> e &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># bit on in the binary representation of the exponent</span>
        <span class="hljs-keyword">if</span> e &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            rtn = (rtn*b) % m
        e &gt;&gt;= <span class="hljs-number">1</span>
        b = (b*b) % m
    <span class="hljs-keyword">return</span> rtn</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean algorithm</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/G">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log b) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extended_gcd</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns (gcd(a, b), x, y) such that ax + by = gcd(a, b). &quot;&quot;&quot;</span>
    x, xp = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    y, yp = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
    r, rp = b, a

    <span class="hljs-keyword">while</span> r != <span class="hljs-number">0</span>:
        q = rp//r
        rp, r = r, rp - q*r
        xp, x = x, xp - q*x
        yp, y = y, yp - q*y

    <span class="hljs-keyword">return</span> rp, xp, yp</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">Modular multiplicative inverse</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/G">Verification</a> - Complexity: same as the Euclidean algorithm</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the inverse y such that xy mod m = 1. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> extended_gcd(x, m)[<span class="hljs-number">1</span>] % m

(a/b) % m == (a*inv(b, m)) % m</code></pre>
<h4 id="factorization"><a href="#factorization" class="header-anchor">Factorization</a></h4>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factor</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Factors a number with trial division. &quot;&quot;&quot;</span>
    l = {<span class="hljs-number">1</span>, n}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:
            l.add(i)
            l.add(n//i)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(l)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Trial_division">Prime Factorization</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/G">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msqrt><mi>x</mi></msqrt><mi mathvariant="normal">/</mi><mi>log</mi><mo>⁡</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\sqrt{x}/\log{x}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">x</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prime_factor</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, primes: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Prime factorizes a number, given a precomputed list of primes. &quot;&quot;&quot;</span>
    l = <span class="hljs-built_in">set</span>()
    rt = <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes:
        <span class="hljs-keyword">if</span> p &gt; rt:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">while</span> n % p == <span class="hljs-number">0</span>:
            n = n//p
            l.add(p)
    <span class="hljs-keyword">if</span> n != <span class="hljs-number">1</span>:
        l.add(n)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(l)</code></pre>
<h3 id="binary"><a href="#binary" class="header-anchor">Binary</a></h3>
<p><a href="http://web.stanford.edu/class/cs166/lectures/16/Slides16.pdf">Most Significant Bit</a> - <a href="">Verification</a> - Complexity: Can be done in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> with some work</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">msb</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the index of the most significant bit of n. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> n.bit_length() - <span class="hljs-number">1</span></code></pre>
<p><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">Brian Kernighan&#39;s set bit count</a> - <a href="">Verification: Othello</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_pos</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Finds the number of 1&#x27;s in a number. &quot;&quot;&quot;</span>
    l = []
    <span class="hljs-keyword">while</span> x:
        xp = x &amp; (x - <span class="hljs-number">1</span>)
        l.append((x - xp).bit_length() - <span class="hljs-number">1</span>)
        x = xp
    <span class="hljs-keyword">return</span> l</code></pre>
<p><a href="">Binary Counter</a> - <a href="">Verification</a> - Complexity: amortized <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> operations</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">c: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Increments a binary counter. &quot;&quot;&quot;</span>
    i = <span class="hljs-number">1</span>
    l = <span class="hljs-number">1</span> &lt;&lt; m
    <span class="hljs-keyword">while</span> i &lt; l <span class="hljs-keyword">and</span> c &amp; i &gt; <span class="hljs-number">0</span>:
        c ^= i
        i &lt;&lt;= <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> i &lt; l:
        c ^= i
    <span class="hljs-keyword">return</span> c</code></pre>
<h3 id="matrices"><a href="#matrices" class="header-anchor">Matrices</a></h3>
<p>Miscellaneous operations</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dotp</span>(<span class="hljs-params">u: <span class="hljs-built_in">list</span>, v: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Dot product. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(u[i]*v[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(u)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">col</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Column of a matrix. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [m[j][i] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">mat_mult</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Matrix multiplication. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [[dotp(a[i], col(b, j)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b[<span class="hljs-number">0</span>]))]
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a))]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Identity matrix of size n x n. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [[<span class="hljs-built_in">int</span>(i == j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_mat</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Pretty prints a matrix. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m:
        <span class="hljs-built_in">print</span>(row)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">mat_exp</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns A^k. &quot;&quot;&quot;</span>
    v = identity(<span class="hljs-built_in">len</span>(A))
    <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            v = mat_mult(v, A)
        k &gt;&gt;= <span class="hljs-number">1</span>
        A = mat_mult(A, A)
    <span class="hljs-keyword">return</span> v</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gauss–Jordan elimination</a> - <a href="https://foobar.withgoogle.com/">Verification: Google Foobar</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n^3) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">m</span>):
    <span class="hljs-string">&quot;&quot;&quot; Inverts a matrix. &quot;&quot;&quot;</span>
    N = <span class="hljs-built_in">len</span>(m)
    <span class="hljs-comment"># augment matrix with identity</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        m[i] += [F(i == j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-comment"># get first nonzero entry</span>
        pivot = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c, N) <span class="hljs-keyword">if</span> m[i][c] != F(<span class="hljs-number">0</span>)][<span class="hljs-number">0</span>]
        m[c], m[pivot] = m[pivot], m[c]
        v = m[c][c]
        <span class="hljs-comment"># set pivot value to 1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m[c])):
            m[c][i] /= v
        <span class="hljs-comment"># make all zeros</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">if</span> r != c:
                v = m[r][c]
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m[r])):
                    m[r][i] -= v*m[c][i]

    <span class="hljs-keyword">return</span> [row[N:] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m]</code></pre>
<h3 id="linear_programming"><a href="#linear_programming" class="header-anchor">Linear Programming</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Simplex_algorithm">Simplex Algorithm</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mo stretchy="false">?</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(?) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">?)</span></span></span></span> &#40;see <a href="https://en.wikipedia.org/wiki/Smoothed_analysis">smoothed analysis</a>&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_dict</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">&quot;&quot;&quot; Converts a list into a dictionary based off indexes. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> {i + <span class="hljs-number">1</span>: l[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l))}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">prog_dict</span>(<span class="hljs-params">A, b, c, contypes, t, nonneg</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Converts the easier list representation to a more general
    dictionary representation used by the simplex algorithm.
    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> (
        {v + <span class="hljs-number">1</span>: {i + <span class="hljs-number">1</span>: A[v][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A[v]))}
         <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))
        },
        list_dict(b), list_dict(c), list_dict(contypes),
        t, {x + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nonneg}
    )

<span class="hljs-keyword">def</span> <span class="hljs-title function_">negated</span>(<span class="hljs-params">d: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">&quot;&quot;&quot; Negates a row. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> {k: -v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">negate</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Negates a row vector. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [-x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> l]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">general_standard</span>(<span class="hljs-params">A, b, c, contypes, t, nonneg</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Converts a general linear program into standard form. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># 1. The objective function is a minimization rather than a maximization</span>
    <span class="hljs-keyword">if</span> t == MIN:
        c = negate(c)
    <span class="hljs-comment"># 2. Variables without nonnegativity constraints</span>
    v = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> v &lt; <span class="hljs-built_in">len</span>(c):
        <span class="hljs-keyword">if</span> v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nonneg:
            c.insert(v + <span class="hljs-number">1</span>, -c[v])
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A)):
                A[i].insert(v + <span class="hljs-number">1</span>, -A[i][v])
            v += <span class="hljs-number">1</span>
        v += <span class="hljs-number">1</span>
    <span class="hljs-comment"># 3. Replace equality constraints with inequalities</span>
    tA, tb, tcontypes = [], [], []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A)):
        <span class="hljs-keyword">if</span> contypes[i] == EQ:
            tA += [A[i]]*<span class="hljs-number">2</span>
            tb += [b[i]]*<span class="hljs-number">2</span>
            tcontypes += [LEQ, GEQ]
        <span class="hljs-keyword">else</span>:
            tA.append(A[i])
            tb.append(b[i])
            tcontypes.append(contypes[i])
    A, b, contypes = tA, tb, tcontypes
    <span class="hljs-comment"># 4. Replace greater than equal to with less than or equal to</span>
    A = [negate(A[i]) <span class="hljs-keyword">if</span> contypes[i] == GEQ <span class="hljs-keyword">else</span> A[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))]
    b = [-b[i] <span class="hljs-keyword">if</span> contypes[i] == GEQ <span class="hljs-keyword">else</span> b[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b))]

    <span class="hljs-keyword">return</span> A, b, c

<span class="hljs-keyword">def</span> <span class="hljs-title function_">standard_slack</span>(<span class="hljs-params">A, b, c</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Converts a linear program in standard form to one in slack form. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(A[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>
    A = {i + n: list_dict(A[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))}
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n)), <span class="hljs-built_in">set</span>(A.keys()), A,
            {i + n: b[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b))}, list_dict(c), <span class="hljs-number">0</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">general_slack</span>(<span class="hljs-params">prog</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Converts a general linear program into slack form. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> standard_slack(*general_standard(*prog))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pivot</span>(<span class="hljs-params">N, B, A, b, c, v, l, e</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the new linear program after replacing x_l with x_e. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># Compute coefficients for the equation with the new basic variable x_e.</span>
    bp, cp, Ap = {}, {}, {v: {} <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> B - {l} | {e}}
    bp[e] = b[l]/A[l][e]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
        Ap[e][j] = A[l][j]/A[l][e]
    Ap[e][l] = <span class="hljs-number">1</span>/A[l][e]
    <span class="hljs-comment"># Compute coefficients of the remaining constraints.</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> B - {l}:
        bp[i] = b[i] - A[i][e]*bp[e]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
            Ap[i][j] = A[i][j] - A[i][e]*Ap[e][j]
        Ap[i][l] = -A[i][e]*Ap[e][l]
    <span class="hljs-comment"># Compute objective function</span>
    vp = v + c[e]*bp[e]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> N - {e}:
        cp[j] = c[j] - c[e]*Ap[e][j]
    cp[l] = -c[e]*Ap[e][l]
    <span class="hljs-comment"># Compute new sets of basic and nonbasic variables.</span>
    Np = N - {e} | {l}
    Bp = B - {l} | {e}

    <span class="hljs-keyword">return</span> Np, Bp, Ap, bp, cp, vp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">N, B, A, b, c, v</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Solves a linear program in slack form
    whose initial basic solution is feasible.
    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">any</span>(x &gt; EPSILON <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> c.values()):
        <span class="hljs-comment"># Bland&#x27;s rule for both e and l</span>
        e = <span class="hljs-built_in">sorted</span>(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> N <span class="hljs-keyword">if</span> c[i] &gt; EPSILON)[<span class="hljs-number">0</span>]
        l = <span class="hljs-built_in">min</span>(B, key=<span class="hljs-keyword">lambda</span> i:
                (b[i]/A[i][e] <span class="hljs-keyword">if</span> A[i][e] &gt; EPSILON <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), i)
               )
        <span class="hljs-keyword">if</span> A[l][e] &lt;= EPSILON:
            <span class="hljs-keyword">return</span> UNBOUNDED + <span class="hljs-string">&quot;$&quot;</span>
        N, B, A, b, c, v = pivot(N, B, A, b, c, v, l, e)
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">tuple</span>(b.get(i, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(N) + <span class="hljs-number">1</span>)),
            v, (N, B, A, b, c, v))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_simplex</span>(<span class="hljs-params">A, b, c</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Determines whether or not a linear program is feasible, and if it
    is, returns a slack form whose initial basic solution is feasible.
    &quot;&quot;&quot;</span>
    k = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b)), key=<span class="hljs-keyword">lambda</span> i: b[i])
    <span class="hljs-comment"># initial basic solution feasible</span>
    <span class="hljs-keyword">if</span> b[k] &gt;= EPSILON:
        <span class="hljs-keyword">return</span> standard_slack(A, b, c)
    <span class="hljs-comment"># objective function -x_0</span>
    cp = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(c) + <span class="hljs-number">1</span>)}
    cp[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>
    N, B, A, b, c, v = standard_slack(A, b, c)
    <span class="hljs-comment"># add -x_0 to each equation in the linear program</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A:
        A[i][<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>
    N |= {<span class="hljs-number">0</span>}
    N, B, A, b, cp, v = pivot(N, B, A, b, cp, v, <span class="hljs-built_in">len</span>(N) + k, <span class="hljs-number">0</span>)
    x, v, (N, B, A, b, cp, v) = solve(N, B, A, b, cp, v)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(v) &lt;= EPSILON:
        N -= {<span class="hljs-number">0</span>}
        <span class="hljs-comment"># remove x_0 from constraints</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A:
            <span class="hljs-keyword">del</span> A[i][<span class="hljs-number">0</span>]
        <span class="hljs-comment"># substitute to form objective function</span>
        cp = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> N}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> A:
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> A[i]:
                    cp[j] -= c[i]*A[i][j]
                v += c[i]*b[i]
            <span class="hljs-keyword">else</span>:
                cp[i] += c[i]
        <span class="hljs-keyword">return</span> N, B, A, b, cp, v
    <span class="hljs-keyword">return</span> INFEASIBLE

<span class="hljs-keyword">def</span> <span class="hljs-title function_">simplex</span>(<span class="hljs-params">prog</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Solves an arbitrary linear program in standard form. &quot;&quot;&quot;</span>
    slack = initialize_simplex(*prog)
    <span class="hljs-keyword">if</span> slack == INFEASIBLE:
        <span class="hljs-keyword">return</span> INFEASIBLE
    <span class="hljs-keyword">return</span> solve(*slack)[:-<span class="hljs-number">1</span>]</code></pre>
<h3 id="fast_fourier_transform"><a href="#fast_fourier_transform" class="header-anchor">Fast Fourier Transform</a></h3>
<p><a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-2">Cooley–Tukey Recursive FFT</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> cmath, math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, inv: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the DFT of a with recursion and complex roots of unity. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(a)
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> a
    wn = cmath.exp((-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> inv <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)*<span class="hljs-number">2</span>*cmath.pi*<span class="hljs-number">1j</span>/n)
    w = <span class="hljs-number">1</span>
    y0, y1 = recur_fft(a[::<span class="hljs-number">2</span>], inv), recur_fft(a[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>], inv)
    y = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n &gt;&gt; <span class="hljs-number">1</span>):
        t = w*y1[k]
        y[k] = y0[k] + t
        y[k + (n &gt;&gt; <span class="hljs-number">1</span>)] = y0[k] - t
        w *= wn
    <span class="hljs-keyword">return</span> y

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_recur_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the inverse DFT of a. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [x/<span class="hljs-built_in">len</span>(a) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> recur_fft(a, <span class="hljs-literal">True</span>)]</code></pre>
<p><a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-5">Cooley–Tukey Iterative FFT</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rev_increment</span>(<span class="hljs-params">c: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Increments a reverse binary counter. &quot;&quot;&quot;</span>
    i = <span class="hljs-number">1</span> &lt;&lt; (m - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> c &amp; i &gt; <span class="hljs-number">0</span>:
        c ^= i
        i &gt;&gt;= <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> c ^ i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bit_rev_copy</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Constructs an initial order from a by reversing the bits of the index. &quot;&quot;&quot;</span>
    n, m = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(a).bit_length() - <span class="hljs-number">1</span>
    A = [<span class="hljs-number">0</span>]*n
    c = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        A[c] = a[i]
        c = rev_increment(c, m)
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">iter_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, inv: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the DFT iteratively. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(a)
    A = bit_rev_copy(a)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n.bit_length()):
        m = <span class="hljs-number">1</span> &lt;&lt; s
        wm = cmath.exp((-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> inv <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)*<span class="hljs-number">2</span>*cmath.pi*<span class="hljs-number">1j</span>/m)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, m):
            w = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m &gt;&gt; <span class="hljs-number">1</span>):
                t = w*A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)]
                u = A[k + j]
                A[k + j] = u + t
                A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)] = u - t
                w *= wm
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_iter_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the inverse DFT of a. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [x/<span class="hljs-built_in">len</span>(a) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iter_fft(a, <span class="hljs-literal">True</span>)]</code></pre>
<p>Readings for the following number theoretic FFT algorithms:</p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Euler&#37;27s_totient_function">Euler&#39;s totient function</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Primitive_root_modulo_n">Primitive root modulo n</a></p>
</li>
<li><p><a href="https://cs170.org/assets/pdf/hw03-sol.pdf">Application of FFT to polynomial multiplication</a></p>
</li>
<li><p><a href="https://www.nayuki.io/page/number-theoretic-transform-integer-dft">The Number Theoretic Transform &#40;NTT&#41;</a></p>
</li>
</ul>
<p><a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-7">Iterative FFT with modulo &#40;NTT&#41;</a> - <a href="https://www.spoj.com/problems/MAXMATCH/">Verification: SPOJ MAXMATCH</a> - Complexity: O&#40;n log n&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_kp</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Finds the smallest k such that p = kn + 1 is prime.
    pi(n) = n/log n, so the probability of a random number
    being prime is 1/log n, expect to try log n numbers
    until finding a prime - expected O((sqrt n)(log n)).
    &quot;&quot;&quot;</span>
    k, p = <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> prime(p):
        k += <span class="hljs-number">1</span>
        p += n
    <span class="hljs-keyword">return</span> k, p

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_generator</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Euler&#x27;s totient function phi(n) gives the
    order of a modulo multiplicative group mod p.
    phi(p) = p - 1 = kn
    prime factors of kn are 2, maybe k
    expected O(log^8 ish n)
    &quot;&quot;&quot;</span>
    prime_factors = [<span class="hljs-number">2</span>] + ([k] <span class="hljs-keyword">if</span> prime(k) <span class="hljs-keyword">else</span> [])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):
        <span class="hljs-comment"># coprime and thus in the group</span>
        <span class="hljs-keyword">if</span> gcd(i, p) == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(mod_exp(i, k*n//factor, p) != <span class="hljs-number">1</span>
                   <span class="hljs-keyword">for</span> factor <span class="hljs-keyword">in</span> prime_factors):
                <span class="hljs-keyword">return</span> i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_wp</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Returns w, the principal nth root of unity
    and p, the prime determining the mod.
    &quot;&quot;&quot;</span>
    k, p = find_kp(n)
    g = find_generator(n, k, p)
    <span class="hljs-keyword">return</span> mod_exp(g, k, p), p

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_w</span>(<span class="hljs-params">w: <span class="hljs-built_in">int</span>, N: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns w, the principal nth root of unity for n. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> mod_exp(w, <span class="hljs-number">1</span> &lt;&lt; (N - n + <span class="hljs-number">1</span>), p)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Compute the DFT iteratively with modulo instead of complex numbers. &quot;&quot;&quot;</span>
    n, lgn = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(a).bit_length()
    A = bit_rev_copy(a)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, lgn):
        m = <span class="hljs-number">1</span> &lt;&lt; s
        wm = mod_exp(wn, <span class="hljs-number">1</span> &lt;&lt; (lgn - s - <span class="hljs-number">1</span>), p)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, m):
            w = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m &gt;&gt; <span class="hljs-number">1</span>):
                t = w*A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)]
                u = A[k + j]
                A[k + j] = (u + t) % p
                A[k + j + (m &gt;&gt; <span class="hljs-number">1</span>)] = (u - t) % p
                w = (w*wm) % p
    <span class="hljs-keyword">return</span> A

<span class="hljs-keyword">def</span> <span class="hljs-title function_">inv_int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the inverse DFT of a. &quot;&quot;&quot;</span>
    wn, n1 = inv(wn, p), inv(<span class="hljs-built_in">len</span>(a), p)
    <span class="hljs-keyword">return</span> [(x*n1) % p <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> int_fft(a, wn, p)]</code></pre>
<p><a href="https://cp-algorithms.com/algebra/fft.html#toc-tgt-7">Recursive FFT with modulo &#40;NTT&#41;</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_int_fft</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, wn: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the DFT of a with recursion and modulo. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(a)
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> a
    w = <span class="hljs-number">1</span>
    y0, y1 = int_fft(a[::<span class="hljs-number">2</span>], (wn*wn) % p, p), int_fft(a[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>], (wn*wn) % p, p)
    y = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n &gt;&gt; <span class="hljs-number">1</span>):
        t = (w*y1[k]) % p
        y[k] = (y0[k] + t) % p
        y[k + (n &gt;&gt; <span class="hljs-number">1</span>)] = (y0[k] - t) % p
        w = (w*wn) % p
    <span class="hljs-keyword">return</span> y</code></pre>
<p>Polynomial Multiplication with the FFT - <a href="https://www.spoj.com/problems/POLYMUL/">Verification: SPOJ POLYMUL</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>Note: make sure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex"> p </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is bigger than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mn>2</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex"> m^2 n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex"> m </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the biggest number in the array and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the length of the array.</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mirror</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    Mirrors a such that the resulting list has a length which is a power of 2.
    &quot;&quot;&quot;</span>
    n, np = <span class="hljs-built_in">len</span>(a), <span class="hljs-number">1</span> &lt;&lt; math.ceil(math.log2(<span class="hljs-built_in">len</span>(a)))
    a += [<span class="hljs-number">0</span>]*(np - n)
    <span class="hljs-comment"># for i in range(np - n):</span>
    <span class="hljs-comment">#     a[n + i] = a[n - i - 2]</span>
    <span class="hljs-keyword">return</span> a

<span class="hljs-keyword">def</span> <span class="hljs-title function_">poly_mult</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">list</span>, w: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Multiplies two polynomials via the modular FFT. &quot;&quot;&quot;</span>
    m = <span class="hljs-built_in">len</span>(a) + <span class="hljs-built_in">len</span>(b) - <span class="hljs-number">1</span>
    n = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b))
    <span class="hljs-comment"># make both lists the same size and degree bound 2n instead of n</span>
    ap = mirror(a + [<span class="hljs-number">0</span>]*(n - <span class="hljs-built_in">len</span>(a)) + [<span class="hljs-number">0</span>]*n)
    bp = mirror(b + [<span class="hljs-number">0</span>]*(n - <span class="hljs-built_in">len</span>(b)) + [<span class="hljs-number">0</span>]*n)
    w = get_w(w, N, <span class="hljs-built_in">len</span>(ap).bit_length(), p)
    ap, bp = int_fft(ap, w, p), int_fft(bp, w, p)
    <span class="hljs-keyword">return</span> inv_int_fft([ap[i]*bp[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ap))], w, p)[:m]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ntt_sign</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Assumes that substantial numbers are signed and therefore negative. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">if</span> x &lt; (p &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> x - p <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> l]

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:
    N = <span class="hljs-number">20</span>
    w, p = find_wp(<span class="hljs-number">1</span> &lt;&lt; N)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Multidimensional_discrete_convolution">2D Convolution</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mi>log</mi><mo>⁡</mo><mrow><mi>n</mi><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(nm \log{nm}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">nm</span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span>, pad=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Flattens a matrix into a list. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> row + [<span class="hljs-number">0</span>]*pad]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">reshape</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Shapes a list into a M x N matrix.&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [[l[r*n + c] <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">conv</span>(<span class="hljs-params">h: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">list</span></span>):
    <span class="hljs-string">&quot;&quot;&quot; Computes the 2D convolution. &quot;&quot;&quot;</span>
    M, N, H, W = <span class="hljs-built_in">len</span>(x), <span class="hljs-built_in">len</span>(x[<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(h), <span class="hljs-built_in">len</span>(h[<span class="hljs-number">0</span>])
    <span class="hljs-comment"># need to pad the columns to the final size</span>
    h, x = flatten(h, N - <span class="hljs-number">1</span>), flatten(x, W - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> reshape(fft(h, x), M + H - <span class="hljs-number">1</span>, N + W - <span class="hljs-number">1</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">prune</span>(<span class="hljs-params">h: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Prunes a convolution for the specific K x K filter case. &quot;&quot;&quot;</span>
    m, k = conv(h, x), <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(h), <span class="hljs-built_in">len</span>(x))
    pad = (k - <span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> [row[pad:-pad] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m[pad:-pad]]</code></pre>
<h2 id="strings"><a href="#strings" class="header-anchor">Strings</a></h2>
<h3 id="suffix_structures"><a href="#suffix_structures" class="header-anchor">Suffix Structures</a></h3>
<h4 id="suffix_array"><a href="#suffix_array" class="header-anchor">Suffix Array</a></h4>
<p>Reference paper: <a href="https://doi.org/10.1109/DCC.2009.42"><em>Linear Suffix Array Construction by Almost Pure Induced-Sorting</em></a>.</p>
<p><a href="http://web.stanford.edu/class/cs166/lectures/04/Small04.pdf">Suffix Array by Induced Sorting</a> - <a href="https://www.spoj.com/problems/SARRAY/">Verification: SPOJ SARRAY</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(m) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lms_block</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span>, t: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">&quot;&quot;&quot; Label each character of s with L (False) or S (True). &quot;&quot;&quot;</span>
    j, l = i + <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>
    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> (l <span class="hljs-keyword">and</span> t[j]):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t[j]:
            l = <span class="hljs-literal">True</span>
        j += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> s[i:j]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">induced_sort</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span>, t: <span class="hljs-built_in">list</span>, blocks: <span class="hljs-built_in">list</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Induced sort of s. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(s)
    c = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        c[s[i]] = c.get(s[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>

    <span class="hljs-comment"># modified bucket sort -</span>
    <span class="hljs-comment"># the size of the alphabet is bounded by the length of the string</span>
    order = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(c), <span class="hljs-built_in">max</span>(c) + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> c]
    b = {order[<span class="hljs-number">0</span>]: [<span class="hljs-number">0</span>, c[order[<span class="hljs-number">0</span>]] - <span class="hljs-number">1</span>]}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(order)):
        b[order[i]] = [b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,
                       b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + c[order[i]]]

    sa = [-<span class="hljs-number">1</span>]*n
    <span class="hljs-keyword">if</span> blocks <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):
            <span class="hljs-comment"># LMS index</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> t[i]:
                sa[b[s[i]][<span class="hljs-number">1</span>]] = i
                b[s[i]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-comment"># given sorted order from recursive call</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(blocks):
            sa[b[s[i]][<span class="hljs-number">1</span>]] = i
            b[s[i]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-comment"># put L types from the front</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        j = sa[i] - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t[j]:
            sa[b[s[j]][<span class="hljs-number">0</span>]] = j
            b[s[j]][<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>

    <span class="hljs-comment"># reset right borders</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(order)):
        b[order[i]] = [b[order[i]][<span class="hljs-number">0</span>],
                       c[order[i]] + (b[order[i - <span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)]

    <span class="hljs-comment"># put S types from the back</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        j = sa[i] - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t[j]:
            sa[b[s[j]][<span class="hljs-number">1</span>]] = j
            b[s[j]][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> sa

<span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_array</span>(<span class="hljs-params">s: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Construct the suffix array for the string s. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># convert a string to an array of integer ordinal values</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(s, <span class="hljs-built_in">str</span>):
        s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>, s))

    n = <span class="hljs-built_in">len</span>(s)
    <span class="hljs-comment"># True is &quot;S&quot; type and &quot;L&quot; is False</span>
    t = [<span class="hljs-literal">True</span>]*n
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> s[i] &lt; s[i + <span class="hljs-number">1</span>]:
            t[i] = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">elif</span> s[i] &gt; s[i + <span class="hljs-number">1</span>]:
            t[i] = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">else</span>:
            t[i] = t[i + <span class="hljs-number">1</span>]

    sa = induced_sort(s, t)

    <span class="hljs-comment"># LMS blocks</span>
    blocks = [sa[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)
              <span class="hljs-keyword">if</span> sa[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t[sa[i]] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t[sa[i] - <span class="hljs-number">1</span>]]

    <span class="hljs-comment"># name blocks</span>
    names = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(blocks)):
        names[blocks[i]] = names.get(blocks[i - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>) + \
            (i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> \
             lms_block(s, t, blocks[i]) != lms_block(s, t, blocks[i - <span class="hljs-number">1</span>])
            )
    blocks = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> names]

    <span class="hljs-comment"># reduced list guaranteed to be &lt; n/2 of the original</span>
    reduced = [names[block] <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]

    <span class="hljs-comment"># all distinct characters - base case</span>
    m = <span class="hljs-built_in">len</span>(reduced)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(reduced)) == m:
        sa1 = [<span class="hljs-number">0</span>]*(m + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
            sa1[reduced[i] + <span class="hljs-number">1</span>] = i
    <span class="hljs-keyword">else</span>:
        sa1 = suffix_array(reduced + [-<span class="hljs-number">1</span>])

    <span class="hljs-comment"># sort blocks by suffix array of reduced string</span>
    temp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(sa1)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(sa1)):
        temp[i] = blocks[sa1[i]]
    blocks = temp

    sa = induced_sort(s, t, blocks)
    <span class="hljs-keyword">return</span> sa</code></pre>
<h5 id="lcp_array"><a href="#lcp_array" class="header-anchor">LCP Array</a></h5>
<p>Reference paper: <a href="https://doi.org/10.1007/3-540-48194-X_17"><em>Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its Applications</em></a></p>
<p><a href="http://web.stanford.edu/class/cs166/lectures/03/Slides03.pdf">Kasai</a> - <a href="http://www.usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;768">Verification: USACO Standing Out</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(m) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcp_array</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot;&quot; Construct the LCP array given a string s and its suffix array sa. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(s)
    rank = [<span class="hljs-number">0</span>]*n
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        rank[sa[i]] = i

    lcp = [<span class="hljs-number">0</span>]*(n - <span class="hljs-number">1</span>)
    h = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">if</span> rank[i] &gt; <span class="hljs-number">1</span>:
            <span class="hljs-comment"># suffix before rank[i] in the suffix array</span>
            k = sa[rank[i] - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">while</span> s[i + h] == s[k + h]:
                h += <span class="hljs-number">1</span>
            lcp[rank[i] - <span class="hljs-number">1</span>] = h
            <span class="hljs-keyword">if</span> h &gt; <span class="hljs-number">0</span>:
                h -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> lcp</code></pre>
<h5 id="generalized_suffix_arrays"><a href="#generalized_suffix_arrays" class="header-anchor">Generalized Suffix Arrays</a></h5>
<p><a href="http://web.stanford.edu/class/cs166/lectures/02/Slides02.pdf">Generalized Suffix Arrays</a> - <a href="http://www.spoj.com/problems/LPS/">Verification: SPOJ LPS</a> - Complexity: O&#40;m&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generalized_suffix_array</span>(<span class="hljs-params">words: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Build a single suffix array on the concatenation of multiple words. &quot;&quot;&quot;</span>
    n = [v <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words)
         <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> (<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>, word)) + [i - <span class="hljs-built_in">len</span>(words)])]
    <span class="hljs-keyword">return</span> n, suffix_array(n)</code></pre>
<h4 id="suffix_tree"><a href="#suffix_tree" class="header-anchor">Suffix Tree</a></h4>
<p><a href="http://web.stanford.edu/class/cs166/lectures/04/Small04.pdf">Suffix Trees</a> - <a href="http://www.spoj.com/problems/STAMMER/">Verification: SPOJ STAMMER</a> - Complexity: O&#40;m&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuffixTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span>, *,
                 start: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span>, end: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># cartesian tree variables</span>
        <span class="hljs-comment"># stores the LCP value for internal nodes</span>
        <span class="hljs-comment"># and the suffix index for leaf nodes</span>
        self.key = key
        self.parent = parent
        self.child = [left, right]

        <span class="hljs-comment"># suffix tree variables</span>
        <span class="hljs-comment"># keyed by first character (distinct)</span>
        self.children = {}
        <span class="hljs-comment"># start and end indexes in the string</span>
        self.start, self.end = start, end
        <span class="hljs-comment"># root contains a copy of the original string</span>
        self.s = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">&quot;&quot;</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">&quot;&quot;&quot; Fancy tree printing (uses the original string to draw edges). &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> self.s <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            rtn = []

            <span class="hljs-comment"># precompute heights</span>
            h = {<span class="hljs-literal">None</span>: -<span class="hljs-number">1</span>, self: <span class="hljs-number">0</span>}
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                    q.append(child)
                    h[child] = h[n] + <span class="hljs-number">1</span>

            <span class="hljs-comment"># actually compute string representation</span>
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                edge = self.s[n.start: n.end + <span class="hljs-number">1</span>] \
                    <span class="hljs-keyword">if</span> n.start <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.end <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>
                <span class="hljs-comment"># edge = (n.start, n.end)</span>
                rtn.append(<span class="hljs-string">&quot;{}{} {}\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot; &quot;</span>*<span class="hljs-number">4</span>*h[n], n.key, edge))
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children, reverse=<span class="hljs-literal">True</span>):
                    q.append(n.children[child])
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(rtn)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;{}{}&quot;</span>.<span class="hljs-built_in">format</span>(self.key, <span class="hljs-string">&quot;$&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.children) == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">&quot;&quot;&quot; Whether s is a substring of the suffix tree. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> self.<span class="hljs-keyword">match</span>(s) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-string">&quot;SuffixTree&quot;</span>:
        <span class="hljs-string">&quot;&quot;&quot;
        Returns the subtree matching the string s, None if it does not exist.
        &quot;&quot;&quot;</span>
        i = <span class="hljs-number">0</span>
        t = self
        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s):
            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t.children:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            t = t.children[s[i]]
            j = t.start
            <span class="hljs-keyword">while</span> j &lt;= t.end <span class="hljs-keyword">and</span> i &lt; <span class="hljs-built_in">len</span>(s):
                <span class="hljs-keyword">if</span> s[i] != self.s[j]:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
                j += <span class="hljs-number">1</span>
                i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> t

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
        <span class="hljs-string">&quot;&quot;&quot; Reports the index of each occurrence of s in the string. &quot;&quot;&quot;</span>
        t = self.<span class="hljs-keyword">match</span>(s)
        l = []
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> l

        stk = [t]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
            n = stk.pop()
            <span class="hljs-comment"># leaf node</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.children) == <span class="hljs-number">0</span>:
                l.append(n.key)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                stk.append(child)

        <span class="hljs-keyword">return</span> l

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_array</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>:
        <span class="hljs-string">&quot;&quot;&quot; Inorder traversal yields a suffix array. &quot;&quot;&quot;</span>
        sa = []
        stk = [self]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
            n = stk.pop()
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.children) == <span class="hljs-number">0</span>:
                sa.append(n.key)
            <span class="hljs-comment"># s log s where s is the size of the alphabet</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children, reverse=<span class="hljs-literal">True</span>):
                stk.append(n.children[k])

        <span class="hljs-keyword">return</span> sa

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_tree</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">&quot;&quot;&quot; Constructs a Cartesian tree for a LCP array in O(n). &quot;&quot;&quot;</span>
    stk = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        c = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>].key &gt; l[i]:
            c = stk.pop()
        stk.append(SuffixTree(l[i], stk[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, c))
        <span class="hljs-comment"># add right child</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">1</span>:
            stk[-<span class="hljs-number">2</span>].child[<span class="hljs-number">1</span>] = stk[-<span class="hljs-number">1</span>]
            <span class="hljs-comment"># merge same values</span>
            <span class="hljs-comment"># if stk[-1].key == stk[-2].key:</span>
            <span class="hljs-comment">#     stk[-2].child[0] = stk[-1].child[0]</span>
            <span class="hljs-comment">#     stk.pop()</span>
    <span class="hljs-keyword">return</span> stk[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">n: SuffixTree, sa: <span class="hljs-built_in">list</span>, sword: <span class="hljs-built_in">list</span>,
            wstart: <span class="hljs-built_in">dict</span>, c: <span class="hljs-built_in">int</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-string">&quot;&quot;&quot; Adds a suffix of the string if the node is missing a child. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> n.child[c] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        end = wstart[sword[sa[i]] + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> \
            <span class="hljs-keyword">if</span> sword[sa[i]] + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(wstart) <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sa) - <span class="hljs-number">1</span>
        n.child[c] = SuffixTree(sa[i], n, start=sa[i] + n.key, end=end)
        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> i

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span>, t: SuffixTree,
        sword: <span class="hljs-built_in">list</span>, wstart: <span class="hljs-built_in">dict</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">&quot;&quot;&quot; Construct a suffix tree from the string s given its suffix array. &quot;&quot;&quot;</span>
    stk = [(t, <span class="hljs-number">0</span>)]
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        i = process(n, sa, sword, wstart, <span class="hljs-number">0</span>, i)
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> p == <span class="hljs-number">2</span>:
            stk.pop()
            i = process(n, sa, sword, wstart, <span class="hljs-number">1</span>, i)
            <span class="hljs-comment"># merge same values</span>
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.key == n.parent.key:
                n.parent.child = [
                    child <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.parent.child + n.child
                    <span class="hljs-keyword">if</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> child.key != n.key
                ]
            <span class="hljs-comment"># label nodes with start and end values</span>
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.child:
                <span class="hljs-keyword">if</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                    <span class="hljs-comment"># min start index of children minus 1</span>
                    child.end = <span class="hljs-built_in">min</span>(child.child,
                                    key=<span class="hljs-keyword">lambda</span> x: x.start).start - <span class="hljs-number">1</span>
                    <span class="hljs-comment"># difference in LCP values</span>
                    child.start = child.end - (child.key - n.key) + <span class="hljs-number">1</span>
                <span class="hljs-comment"># key by first character of edge</span>
                n.children[s[child.start]] = child
                child.parent = n

        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = n.child[p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> child.start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                stk.append((child, <span class="hljs-number">0</span>))
    <span class="hljs-comment"># copy original string to convert (start, end) into substrings</span>
    t.s = s
    <span class="hljs-comment"># additional state information</span>
    t.sword, t.wstart = sword, wstart
    <span class="hljs-keyword">return</span> t

<span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_tree</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, sa: <span class="hljs-built_in">list</span>, lcp: <span class="hljs-built_in">list</span>,
                word: <span class="hljs-built_in">list</span>=[], start: <span class="hljs-built_in">dict</span>={}</span>) -&gt; SuffixTree:
    <span class="hljs-string">&quot;&quot;&quot; Constructs a suffix tree for a string in O(n). &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> dfs(s, sa, cartesian_tree(lcp),
               word <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(s),
               start <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(start) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> {s: <span class="hljs-number">0</span>})</code></pre>
<h4 id="todo"><a href="#todo" class="header-anchor">TODO</a></h4>
<p>Ukkonen&#39;s algorithm &#40;direct construction&#41;</p>
<p>Lectures:</p>
<ul>
<li><p><a href="https://www2.cs.duke.edu/courses/fall14/compsci260/resources/suffix.trees.in.detail.pdf">Duke</a></p>
</li>
<li><p><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf">CMU</a></p>
</li>
<li><p><a href="https://web.stanford.edu/~mjkay/gusfield.pdf">Stanford</a></p>
</li>
</ul>
<h5 id="generalized_suffix_tree"><a href="#generalized_suffix_tree" class="header-anchor">Generalized Suffix Tree</a></h5>
<p><a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1186/lectures/03/Small03.pdf">Generalized Suffix Tree</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generalized_suffix_tree</span>(<span class="hljs-params">words: <span class="hljs-built_in">list</span></span>) -&gt; SuffixTree:
    <span class="hljs-string">&quot;&quot;&quot; Construct a suffix tree on the concatenation of multiple words. &quot;&quot;&quot;</span>
    s, sword, wstart = [], [], {}
    j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):
        wstart[i] = j
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word)):
            s.append(word[k])
            sword.append(i)
            j += <span class="hljs-number">1</span>
        s.append(<span class="hljs-built_in">chr</span>(<span class="hljs-number">128</span> + i))
        sword.append(i)
        j += <span class="hljs-number">1</span>
    sword.append(<span class="hljs-built_in">len</span>(words))

    s = <span class="hljs-string">&quot;&quot;</span>.join(s) + <span class="hljs-string">&quot;$&quot;</span>
    sa = suffix_array(s)
    lcp = lcp_array(s, sa)

    t = suffix_tree(s, sa, lcp, sword, wstart)
    <span class="hljs-keyword">return</span> t</code></pre>
<h5 id="suffix_tree_to_dag"><a href="#suffix_tree_to_dag" class="header-anchor">Suffix Tree to DAG</a></h5>
<p>Suffix Tree to DAG - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">suffix_tree_dag</span>(<span class="hljs-params">t: SuffixTree</span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">&quot;&quot;&quot; Converts a suffix tree to a numeric DAG. &quot;&quot;&quot;</span>
    ids, graph = {t: <span class="hljs-number">0</span>}, {}
    stk = [t]
    i = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">if</span> ids[n] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:
            graph[ids[n]] = []
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            ids[child] = i
            i += <span class="hljs-number">1</span>
            graph[ids[n]].append(ids[child])
            stk.append(child)
    <span class="hljs-keyword">return</span> ids, graph</code></pre>
<h3 id="matching"><a href="#matching" class="header-anchor">Matching</a></h3>
<h4 id="aho-corasick"><a href="#aho-corasick" class="header-anchor">Aho-Corasick</a></h4>
<p><a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf">Aho-Corasick</a> - <a href="http://www.usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;533">Verification: USACO Censoring</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> \langle \mathcal{O}(n), \mathcal{O}(m + z) \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)⟩</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ch=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.children = {}                           <span class="hljs-comment"># pointers to children</span>
        self.ch = ch <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ch, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment"># character</span>
        self.end = []                                <span class="hljs-comment"># represents a pattern</span>
        self.suffix = self.output = <span class="hljs-literal">None</span>             <span class="hljs-comment"># aho-corasick</span>

        <span class="hljs-comment"># create trie from list of patterns</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ch, <span class="hljs-built_in">list</span>):
            <span class="hljs-keyword">for</span> i, pattern <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(ch):
                self.add(pattern, i)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> self.ch == <span class="hljs-string">&quot;&quot;</span>:
            rtn = []

            <span class="hljs-comment"># precompute heights</span>
            h = {<span class="hljs-literal">None</span>: -<span class="hljs-number">1</span>, self: <span class="hljs-number">0</span>}
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
                    q.append(child)
                    h[child] = h[n] + <span class="hljs-number">1</span>

            <span class="hljs-comment"># actually compute string representation</span>
            q = [self]
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
                n = q.pop()
                rtn.append(<span class="hljs-string">&quot;{}{}{}:{} {}\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot; &quot;</span>*h[n], n.ch,
                                                   <span class="hljs-string">&quot;$&quot;</span> <span class="hljs-keyword">if</span> n.end <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>,
                                                   h[n.suffix], h[n.output]))
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(n.children.values(),
                                    reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x: x.ch):
                    q.append(child)
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(rtn)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;{}{}&quot;</span>.<span class="hljs-built_in">format</span>(self.ch, <span class="hljs-string">&quot;$&quot;</span> <span class="hljs-keyword">if</span> self.end <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">&quot;&quot;&quot; Add s to the trie. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.children:
                self.children[ch] = Trie(ch)
            self = self.children[ch]
        self.end.append(<span class="hljs-built_in">id</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">root: Trie</span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes the suffix links and output links for a given trie. &quot;&quot;&quot;</span>
    q = deque([(<span class="hljs-literal">None</span>, root)])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        prev, n = q.popleft()
        <span class="hljs-keyword">if</span> prev <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-comment"># suffix links</span>
            x = prev.suffix
            <span class="hljs-keyword">while</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">if</span> n.ch <span class="hljs-keyword">in</span> x.children:
                    n.suffix = x.children[n.ch]
                    <span class="hljs-keyword">break</span>
                x = x.suffix
            <span class="hljs-keyword">else</span>:
                n.suffix = root

            <span class="hljs-comment"># output links</span>
            n.output = n.suffix <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.suffix.end) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> n.suffix.output
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            q.append((n, child))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">aho_corasick</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, patterns: <span class="hljs-built_in">list</span>, t: Trie=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Return all matches of patterns in s with the Aho-Corasick automata. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># create automata or use precomputed</span>
    <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        root = Trie(patterns)
        link(root)
        t = root

    <span class="hljs-comment"># find matches</span>
    matches = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(patterns)
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">while</span> ch <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t.children <span class="hljs-keyword">and</span> t.ch != <span class="hljs-string">&quot;&quot;</span>:
            t = t.suffix
        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> t.children:
            t = t.children[ch]
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.end) &gt; <span class="hljs-number">0</span>:
            matches[t.end[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>
        word = t.output
        <span class="hljs-keyword">while</span> word <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            matches[word.end[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>
            word = word.output

    <span class="hljs-comment"># reuse values for duplicated patterns</span>
    stk = [root]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(n.end)):
            matches[n.end[i]] = matches[n.end[<span class="hljs-number">0</span>]]
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.children.values():
            stk.append(child)

    <span class="hljs-keyword">return</span> matches</code></pre>
<h4 id="knuth-morris-pratt"><a href="#knuth-morris-pratt" class="header-anchor">Knuth-Morris-Pratt</a></h4>
<p><a href="https://web.stanford.edu/class/cs97si/10-string-algorithms.pdf">Knuth-Morris-Pratt</a> - <a href="https://www.spoj.com/problems/EC_WORLD/">Verification: SPOJ Rotations</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> \langle \mathcal{O}(n), \mathcal{O}(m) \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)⟩</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prefix_function</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    pi = [-<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(s)
    k = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):
        <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[k + <span class="hljs-number">1</span>] != s[i]:
            k = pi[k]
        <span class="hljs-keyword">if</span> s[k + <span class="hljs-number">1</span>] == s[i]:
            k += <span class="hljs-number">1</span>
        pi[i] = k
    <span class="hljs-keyword">return</span> pi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    pi = prefix_function(p)
    k = -<span class="hljs-number">1</span>
    matches = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):
        <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> p[k + <span class="hljs-number">1</span>] != s[i]:
            k = pi[k]
        <span class="hljs-keyword">if</span> p[k + <span class="hljs-number">1</span>] == s[i]:
            k += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(p) - <span class="hljs-number">1</span>:
            matches.append(i - <span class="hljs-built_in">len</span>(p) + <span class="hljs-number">1</span>)
            k = pi[k]
    <span class="hljs-keyword">return</span> matches</code></pre>
<h2 id="dynamic_programming"><a href="#dynamic_programming" class="header-anchor">Dynamic Programming</a></h2>
<h3 id="memoization"><a href="#memoization" class="header-anchor">Memoization</a></h3>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache

sys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>)

<span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">*args, **kwargs</span>):
    ...

<span class="hljs-built_in">print</span>(recur.cache_info())</code></pre>
<h2 id="graph_algorithms"><a href="#graph_algorithms" class="header-anchor">Graph Algorithms</a></h2>
<h3 id="traversals"><a href="#traversals" class="header-anchor">Traversals</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a> - <a href="">Verification: AI</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">&quot;&quot;&quot; Breadth-first search on graph from start. &quot;&quot;&quot;</span>
    seen = {start}
    q = deque([start])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n = q.popleft()
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(child)
                q.append(child)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a> - <a href="">Verification: AI</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">&quot;&quot;&quot; Depth-first search on graph from start. &quot;&quot;&quot;</span>
    seen = {start}
    stk = [start]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(child)
                stk.append(child)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Tree_traversal">Iterative post-order depth-first search</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, u</span>):
    <span class="hljs-string">&quot;&quot;&quot; Iterative post-order depth-first search. &quot;&quot;&quot;</span>
    seen = {u}
    stk = [(u, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Tree_traversal">Iterative post-order DFS &#40;without indexing children&#41;</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, u</span>):
    <span class="hljs-string">&quot;&quot;&quot; Iterative post-order depth-first search. &quot;&quot;&quot;</span>
    done, seen = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                done.add(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    stk.append(child)</code></pre>
<h4 id="eulerian_tour"><a href="#eulerian_tour" class="header-anchor">Eulerian Tour</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian Tour</a> - <a href="https://train.usaco.org/usacoprob2?a&#61;TpH8RHs6Taa&amp;S&#61;fence">Verification: USACO Training Riding the Fences</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eulerian_tour</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Finds a Eulerian tour or walk of the graph, whichever is possible. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># remove nodes with no edges</span>
    graph = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> graph.items() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v) &gt; <span class="hljs-number">0</span>}
    count = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">len</span>(graph[v]) % <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph)
    <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> count != <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-comment"># no such tour</span>
    start = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
        <span class="hljs-built_in">next</span>((v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[v]) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>))

    stk = [(start, <span class="hljs-number">0</span>)]
    tour = []
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            tour.append(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-comment"># edges have a unique id - (vertex, id)</span>
            <span class="hljs-keyword">if</span> (child[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen):
                stk.append((child[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>))
                seen.add(child[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> tour[::-<span class="hljs-number">1</span>]</code></pre>
<h4 id="topological_sort"><a href="#topological_sort" class="header-anchor">Topological Sort</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sort</a> - <a href="https://leetcode.com/problems/course-schedule-ii/">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, order: <span class="hljs-built_in">list</span>, done: <span class="hljs-built_in">set</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Depth-first search on graph from start. &quot;&quot;&quot;</span>
    stk = [u]
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                done.add(n)
                order.append(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                    <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                        stk.append(child)
                    <span class="hljs-comment"># cycle, child processed before</span>
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">topological_sort</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Toplogical ordering on the directed acylic graph. &quot;&quot;&quot;</span>
    order, done = [], <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> graph:
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
            <span class="hljs-keyword">if</span> dfs(graph, n, order, done):
                <span class="hljs-keyword">return</span> []
    <span class="hljs-keyword">return</span> order[::-<span class="hljs-number">1</span>]</code></pre>
<h3 id="shortest_path"><a href="#shortest_path" class="header-anchor">Shortest Path</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Dijkstra&#37;27s_algorithm">Dijkstra</a> - <a href="https://train.usaco.org/usacoprob2?a&#61;TpH8RHs6Taa&amp;S&#61;butter">Verification: USACO Training Sweet Butter</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}((E + V) \log V) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> &#40;I think&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> heapq

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, i</span>):
    <span class="hljs-string">&quot;&quot;&quot; Single-source shortest path for the graph starting at i. &quot;&quot;&quot;</span>
    dists = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    dists[i] = <span class="hljs-number">0</span>
    pq = [(dists[i], i)]
    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dist, n = heapq.heappop(pq)
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">continue</span>
        seen.add(n)
        <span class="hljs-keyword">for</span> c, w <span class="hljs-keyword">in</span> graph[n].items():
            <span class="hljs-keyword">if</span> dists[n] + w &lt; dists[c]:
                dists[c] = dists[n] + w
                paths[c] = n
                <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    heapq.heappush(pq, (dists[c], c))
    <span class="hljs-keyword">return</span> dists, paths</code></pre>
<p>Dijkstra assuming the priority queue provides a <code>.update&#40;key, value&#41;</code> function</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_dijkstra</span>(<span class="hljs-params">graph, i</span>):
    <span class="hljs-string">&quot;&quot;&quot; Single-source shortest path for the graph starting at i. &quot;&quot;&quot;</span>
    dists = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    dists[i] = <span class="hljs-number">0</span>
    pq = BST()
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph:
        pq.add((<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">if</span> v != i <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, v), v)

    seen = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dist, n = pq.pop()
        dist = dist[<span class="hljs-number">0</span>]
        seen.add(n)
        <span class="hljs-keyword">for</span> c, w <span class="hljs-keyword">in</span> graph[n].items():
            <span class="hljs-keyword">if</span> dists[n] + w &lt; dists[c] <span class="hljs-keyword">and</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                temp = dists[c]
                dists[c] = dists[n] + w
                paths[c] = n
                pq.update((temp, c), c, (dists[c], c))
    <span class="hljs-keyword">return</span> dists, paths</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Floyd&#37;E2&#37;80&#37;93Warshall_algorithm">Floyd-Warshall</a> - <a href="https://train.usaco.org/usacoprob2?a&#61;TpH8RHs6Taa&amp;S&#61;comehome">Verification: USACO Training Bessie Come Home</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V^3) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd_warshall</span>():
    <span class="hljs-string">&quot;&quot;&quot; All-pairs shortest path for the graph. &quot;&quot;&quot;</span>
    m = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)]*N <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            m[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> \
                (graph[i][j] <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> graph[i] <span class="hljs-keyword">else</span> m[i][j])

    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
                <span class="hljs-keyword">if</span> m[i][k] + m[k][j] &lt; m[i][j]:
                     m[i][j] = m[i][k] + m[k][j]</code></pre>
<p>Floyd-Warshall for sparse graphs - <a href="https://train.usaco.org/usacoprob2?a&#61;TpH8RHs6Taa&amp;S&#61;cowtour">Verification: USACO Training Cow Tours</a></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd_warshall</span>():
    <span class="hljs-string">&quot;&quot;&quot; All-pairs shortest path for the graph. &quot;&quot;&quot;</span>
    m = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)]*N <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            m[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> \
                (graph[i][j] <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> graph[i] <span class="hljs-keyword">else</span> m[i][j])

    poss = [<span class="hljs-built_in">set</span>([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N) <span class="hljs-keyword">if</span> row[i] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> m]

    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> poss[i]: <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> poss[k]:
                <span class="hljs-keyword">if</span> m[i][k] + m[k][j] &lt; m[i][j]:
                     m[i][j] = m[i][k] + m[k][j]
                     poss[i].add(j)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan Distance</a></p>
<pre><code class="python hljs">manhat = <span class="hljs-keyword">lambda</span> i, j, x, y: <span class="hljs-built_in">abs</span>(i - x) + <span class="hljs-built_in">abs</span>(j - y)</code></pre>
<p><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> - <a href="">Verification: AI</a> - Complexity: ???</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Astar</span>(<span class="hljs-params">start</span>):
    <span class="hljs-string">&quot;&quot;&quot; Single-source shortest path for the graph. &quot;&quot;&quot;</span>
    seen = <span class="hljs-built_in">set</span>()
    pq = [(dist(start), start, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) &gt; <span class="hljs-number">0</span>:
        dis, n, moves = heapq.heappop(pq)
        <span class="hljs-keyword">if</span> n == goal:
            <span class="hljs-keyword">return</span> moves
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> get_children(n):
            heapq.heappush(pq,
                           (heuristic(child) + moves + <span class="hljs-number">1</span>, child, moves + <span class="hljs-number">1</span>)
                          )
        seen.add(n)</code></pre>
<h3 id="union-find"><a href="#union-find" class="header-anchor">Union-find</a></h3>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_18_Union_Find_and_MST.pdf">Union-find &#40;or disjoint-set&#41;</a> - <a href="http://usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;646">Verification: USACO Closing</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\alpha(N)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex"> \alpha </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> is the inverse <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a>.</p>
<div class="centering"><figure><a href="https://cdn.myanimelist.net/images/characters/15/358414.jpg"><img alt="Mikasa Ackerman" src="/assets/blog/algorithm-library/358414.webp" width="225" height="350"></a> <figcaption><a href="https://myanimelist.net/character/40881/Mikasa_Ackerman">Mikasa Ackerman</a>.</figcaption></figure></div>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">union_init</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Initialize the union-find data structure. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> {i: i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)}, {i: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Find the root of u. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> parent[u] == u:
        <span class="hljs-keyword">return</span> u
    parent[u] = find(parent, parent[u])
    <span class="hljs-keyword">return</span> parent[u]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, size: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">&quot;&quot;&quot; Union the components of u and v. &quot;&quot;&quot;</span>
    ur, vr = find(parent, u), find(parent, v)
    <span class="hljs-keyword">if</span> ur == vr:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    x, y = (ur, vr) <span class="hljs-keyword">if</span> size[ur] &lt; size[vr] <span class="hljs-keyword">else</span> (vr, ur)
    parent[x] = y
    size[y] += size[x]
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>
<p>Iterative variant</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">parent: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Find the root of u. &quot;&quot;&quot;</span>
    i = u
    <span class="hljs-keyword">while</span> parent[i] != i:
        i = parent[i]
    <span class="hljs-keyword">while</span> parent[u] != u:
        p = parent[u]
        parent[u] = i
        u = p
    <span class="hljs-keyword">return</span> i</code></pre>
<h3 id="minimum_spanning_tree"><a href="#minimum_spanning_tree" class="header-anchor">Minimum Spanning Tree</a></h3>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_18_Union_Find_and_MST.pdf">Kruskal</a> - <a href="http://www.usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;101">Verification: USACO Simplify</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(E \log E) = \mathcal{O}(E \log V) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kruskal</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Find the minimum spanning tree of the graph with Kruskal&#x27;s. &quot;&quot;&quot;</span>
    parent, size = {u: u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph}, {u: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph}
    span = []
    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>((graph[u][v], u, v)
                    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u] <span class="hljs-keyword">if</span> v &gt; u):
        w, u, v = e
        <span class="hljs-keyword">if</span> find(parent, u) != find(parent, v):
            span.append((w, u, v))
            union(parent, size, u, v)
    <span class="hljs-keyword">return</span> span</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Prim&#37;27s_algorithm">Prim</a> - <a href="https://train.usaco.org/usacoprob2?a&#61;TpH8RHs6Taa&amp;S&#61;agrinet">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V^2) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prim</span>(<span class="hljs-params">m: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Find the minimum spanning tree of the graph with Prim&#x27;s. &quot;&quot;&quot;</span>
    distances = {i: <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    paths = {i: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    tree = {i: <span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m))}
    size, cost = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
    tree[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m)):
        distances[i] = m[<span class="hljs-number">0</span>][i]
        paths[i] = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> size &lt; <span class="hljs-built_in">len</span>(m):
        i = <span class="hljs-built_in">min</span>(distances,
                key=<span class="hljs-keyword">lambda</span> x: distances[x] <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tree[x] <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>))
        size += <span class="hljs-number">1</span>
        cost += distances[i]
        tree[i] = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(m)):
            <span class="hljs-keyword">if</span> distances[j] &gt; m[i][j]:
                distances[j] = m[i][j]
                paths[j] = i
    <span class="hljs-keyword">return</span> cost</code></pre>
<h3 id="connected_components"><a href="#connected_components" class="header-anchor">Connected Components</a></h3>
<p>Important if using recursion</p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> sys
sys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">6</span>)</code></pre>
<h4 id="undirected"><a href="#undirected" class="header-anchor">Undirected</a></h4>
<p>Connected components - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/238084/problem/I">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">&quot;&quot;&quot; Assign u and its children to the component num. &quot;&quot;&quot;</span>
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        ids[n] = num
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
                ids[child] = num
                stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">connected</span>(<span class="hljs-params">graph</span>):
    <span class="hljs-string">&quot;&quot;&quot; Find the connected components of the graph. &quot;&quot;&quot;</span>
    ids, num = {}, <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:
        <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
            assign(u, num, ids)
            num += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> ids, num</code></pre>
<h4 id="directed_strongly_connected_components"><a href="#directed_strongly_connected_components" class="header-anchor">Directed &#40;Strongly connected components&#41;</a></h4>
<p>Recursion bad - see iterative post-order/assign</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>), l=deque(<span class="hljs-params">[]</span>)</span>):
    <span class="hljs-string">&quot;&quot;&quot; Visit u and its children. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
        seen.add(u)
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> reverse[u]:
            visit(v, seen, l)
        l.appendleft(u)
    <span class="hljs-keyword">return</span> seen, l

<span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">&quot;&quot;&quot; Assign u and its children to the component num. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
        ids[u] = num
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:
            assign(v, num, ids)
    <span class="hljs-keyword">return</span> ids</code></pre>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_01_Strongly_Connected_Components.pdf">Kosaraju-Sharir</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/A">Verification</a> - Complexity: O&#40;V &#43; E&#41;</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign</span>(<span class="hljs-params">u, num, ids={}</span>):
    <span class="hljs-string">&quot;&quot;&quot; Assign u and its children to the component num. &quot;&quot;&quot;</span>
    stk = [u]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk.pop()
        ids[n] = num
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
                ids[child] = num
                stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>), l=deque(<span class="hljs-params">[]</span>)</span>):
    <span class="hljs-string">&quot;&quot;&quot; Visit u and its children. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [u]
    done = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># done with children</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> done:
                l.appendleft(n)
                done.add(n)
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            seen.add(n)
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> reverse[n]:
                <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                    stk.append(child)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">kosaraju_sharir</span>(<span class="hljs-params">graph</span>):
    <span class="hljs-string">&quot;&quot;&quot; Find the strongly connected components with Kosaraju-Sharir. &quot;&quot;&quot;</span>
    seen, l = <span class="hljs-built_in">set</span>(), deque([])
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:
        visit(u, seen, l)
    ids, num = {}, <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> l:
        <span class="hljs-keyword">if</span> u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ids:
            assign(u, num, ids)
            num += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> ids, num</code></pre>
<p>Recover components from ids</p>
<pre><code class="python hljs">comps = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)}
<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> ids.items():
    comps[value].append(key)</code></pre>
<h3 id="tree"><a href="#tree" class="header-anchor">Tree</a></h3>
<h4 id="lca"><a href="#lca" class="header-anchor">LCA</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Lowest Common Ancestor</a> - <a href="">Verification: PClassic</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> \langle 0, \mathcal{O}(n) \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)⟩</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">graph, start</span>):
    <span class="hljs-string">&quot;&quot;&quot; Breadth-first search on graph from start. &quot;&quot;&quot;</span>
    heights = {}
    parents = {start: start}
    q = deque([(start, <span class="hljs-number">0</span>)])
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n, h = q.popleft()
        heights[n] = h
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> heights:
                heights[child] = h + <span class="hljs-number">1</span>
                parents[child] = n
                q.append((child, h + <span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> heights, parents

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">heights, parents, u, v</span>):
    h1, h2 = heights[u], heights[v]
    x, y = (u, v) <span class="hljs-keyword">if</span> h1 &gt; h2 <span class="hljs-keyword">else</span> (v, u)
    <span class="hljs-keyword">while</span> h1 != h2:
        x = parents[x]
        <span class="hljs-keyword">if</span> h1 &gt; h2:
            h1 -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            h2 -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> x != y:
        x = parents[x]
        y = parents[y]
    <span class="hljs-keyword">return</span> x</code></pre>
<h5 id="2n_jump_pointers"><a href="#2n_jump_pointers" class="header-anchor">2^n Jump Pointers</a></h5>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_10_25_LCA.pdf">Jump Pointers</a> - <a href="http://www.usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;576">Verification: USACO Max Flow</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> \langle \mathcal{O}(n \log n), \mathcal{O}(\log n) \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)⟩</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">build_table</span>(<span class="hljs-params">parents: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Builds a 2^n jump pointer table in O(n log n) &quot;&quot;&quot;</span>
    n, m = <span class="hljs-built_in">len</span>(parents), math.ceil(math.log2(<span class="hljs-built_in">len</span>(parents)))
    dp = [[<span class="hljs-number">0</span>]*m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i][<span class="hljs-number">0</span>] = parents[i]

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            dp[i][j + <span class="hljs-number">1</span>] = dp[dp[i][j]][j]

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">table: <span class="hljs-built_in">list</span>, u: <span class="hljs-built_in">int</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the ancestor d height above a node u in O(log d). &quot;&quot;&quot;</span>
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> d &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> d &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:
            u = table[u][i]
        d &gt;&gt;= <span class="hljs-number">1</span>
        i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> u

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">heights: <span class="hljs-built_in">dict</span>, table: <span class="hljs-built_in">list</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the Lowest Common Ancestor (LCA) in O(log n) &quot;&quot;&quot;</span>
    h1, h2 = heights[u], heights[v]
    x, y = (u, v) <span class="hljs-keyword">if</span> h1 &gt; h2 <span class="hljs-keyword">else</span> (v, u)
    x = jump(table, x, <span class="hljs-built_in">abs</span>(h1 - h2))
    <span class="hljs-keyword">if</span> x == y: <span class="hljs-keyword">return</span> x

    i = <span class="hljs-built_in">len</span>(table[x]) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> table[x][i] != table[y][i]:
            x, y = table[x][i], table[y][i]
        i -= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> table[x][<span class="hljs-number">0</span>]</code></pre>
<h5 id="lca_with_range_minimum_query"><a href="#lca_with_range_minimum_query" class="header-anchor">LCA with Range Minimum Query</a></h5>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1819/2019_2_11_LCA.pdf">Euler Tour</a> - <a href="http://www.usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;576">Verification: USACO Max Flow</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> \langle \mathcal{O}(n), \mathcal{O}(1) \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)⟩</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">u</span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Euler tour on the tree rooted at u. &quot;&quot;&quot;</span>
    stk = [(u, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]
    seen = <span class="hljs-built_in">set</span>()
    seen.add(u)
    left, right, l = {}, [], []
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p, h = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()

            left[n] = <span class="hljs-built_in">len</span>(l)
            right.append(n)
            l.append(h)
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>, h)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>, h + <span class="hljs-number">1</span>))
                seen.add(child)

                left[n] = <span class="hljs-built_in">len</span>(l)
                right.append(n)
                l.append(h)
    <span class="hljs-keyword">return</span> left, right, l

indexes, inv, array = traversal(<span class="hljs-number">0</span>)
fh = fischer_heun(array)
l = inv[rmq(array, *fh, indexes[a], indexes[b])]</code></pre>
<h4 id="heavy-light_decomposition"><a href="#heavy-light_decomposition" class="header-anchor">Heavy-Light Decomposition</a></h4>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1819/2019_3_15_HLD.pdf">Heavy-Light Decomposition</a> - <a href="http://usaco.org/index.php?page&#61;viewproblem2&amp;cpid&#61;970">Verification: USACO Milk Visits</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hld</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Heavy-light decomposition of the tree. &quot;&quot;&quot;</span>
    parents = {start: start}
    heights = {start: <span class="hljs-number">0</span>}
    heavy = {}
    size = {u: <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    largest = {u: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    stk = [(start, <span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
                size[n] += size[child]
                <span class="hljs-comment"># heavy edge is the largest subtree out of a node&#x27;s children</span>
                <span class="hljs-keyword">if</span> child != parents[n] <span class="hljs-keyword">and</span> size[child] &gt; largest[n]:
                    largest[n] = size[child]
                    heavy[n] = child
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
              stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> parents:
                parents[child] = n
                heights[child] = heights[n] + <span class="hljs-number">1</span>
                stk.append((child, <span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> parents, heights, heavy

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hld_decomp</span>(<span class="hljs-params">graph: <span class="hljs-built_in">dict</span>, heavy: <span class="hljs-built_in">dict</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Heavy-light decomposition of the tree. &quot;&quot;&quot;</span>
    cur = <span class="hljs-number">0</span>
    head, indexes = {}, {}
    array = []
    seen = <span class="hljs-built_in">set</span>()
    seen.add(start)
    stk = [(start, start)]
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, h = stk.pop()
        head[n] = h
        indexes[n] = cur
        array.append(n)
        cur += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph[n]:
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen <span class="hljs-keyword">and</span> child != heavy.get(n, <span class="hljs-literal">None</span>):
                seen.add(child)
                stk.append((child, child))
        <span class="hljs-comment"># traverse heavy edges first, since it&#x27;s a stack it goes after</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> heavy:
            seen.add(heavy[n])
            stk.append((heavy[n], h))
    <span class="hljs-keyword">return</span> head, indexes, array

<span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">parents: <span class="hljs-built_in">dict</span>, heights: <span class="hljs-built_in">dict</span>, head: <span class="hljs-built_in">dict</span>,
          array: <span class="hljs-built_in">dict</span>, indexes: <span class="hljs-built_in">dict</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    ans = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> head[u] != head[v]:
        u, v = (u, v) <span class="hljs-keyword">if</span> heights[head[u]] &gt; heights[head[v]] <span class="hljs-keyword">else</span> (v, u)
        mx = <span class="hljs-number">0</span>
        <span class="hljs-comment"># mx = rmq(array, indexes[head[u]], indexes[v])</span>
        ans = ans <span class="hljs-keyword">if</span> ans &gt; mx <span class="hljs-keyword">else</span> mx
        u = parents[head[u]]
    u, v = (u, v) <span class="hljs-keyword">if</span> heights[u] &lt; heights[v] <span class="hljs-keyword">else</span> (v, u)
    mx = <span class="hljs-number">0</span>
    <span class="hljs-comment"># mx = rmq(array, indexes[u], indexes[v])</span>
    ans = ans <span class="hljs-keyword">if</span> ans &gt; mx <span class="hljs-keyword">else</span> mx
    <span class="hljs-keyword">return</span> ans</code></pre>
<h4 id="tree_to_array"><a href="#tree_to_array" class="header-anchor">Tree to Array</a></h4>
<p><a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/B">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V + E) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_to_dag</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>)</span>):
    <span class="hljs-string">&quot;&quot;&quot; Turn a tree into a DAG. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [(u, <span class="hljs-number">0</span>)]
    seen.add(u)
    new = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))}
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)
                new[n].append(child)
    <span class="hljs-keyword">return</span> new

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u, seen=<span class="hljs-built_in">set</span>(<span class="hljs-params"></span>)</span>):
    <span class="hljs-string">&quot;&quot;&quot; Depth-first search on graph from start. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> u <span class="hljs-keyword">in</span> seen: <span class="hljs-keyword">return</span>
    stk = [(u, <span class="hljs-number">0</span>)]
    seen.add(u)
    indexes = {}
    used = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span>:
        n, p = stk[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># either leaf or done with children</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(graph[n]) == p:
            <span class="hljs-keyword">if</span> p == <span class="hljs-number">0</span>:
                used += <span class="hljs-number">1</span>
                indexes[n] = (used, used)
            <span class="hljs-keyword">else</span>:
                l, r = indexes[graph[n][<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>], indexes[graph[n][-<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>
                indexes[n] = (l, r)
                used = r
            stk.pop()
        <span class="hljs-comment"># has children left to process</span>
        <span class="hljs-keyword">else</span>:
            child = graph[n][p]
            stk[-<span class="hljs-number">1</span>] = (n, p + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                stk.append((child, <span class="hljs-number">0</span>))
                seen.add(child)
    <span class="hljs-keyword">return</span> indexes</code></pre>
<h3 id="flow"><a href="#flow" class="header-anchor">Flow</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Edmonds&#37;E2&#37;80&#37;93Karp_algorithm">Edmonds-Karp</a> - <a href="https://www.spoj.com/problems/MTOTALF/">Verification: SPOJ MTOTALF</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>V</mi><msup><mi>E</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(V E^2) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">c, f, s, t</span>):
    <span class="hljs-string">&quot;&quot;&quot; Breadth-first search on graph from start. &quot;&quot;&quot;</span>
    q = deque([(s, <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>))])
    paths = {s: <span class="hljs-literal">None</span>}
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:
        n, flow = q.popleft()
        <span class="hljs-keyword">if</span> n == t:
            <span class="hljs-keyword">return</span> flow, paths
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> c[n]:
            cf = c[n][child] - f[n][child]
            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> paths <span class="hljs-keyword">and</span> cf &gt; <span class="hljs-number">0</span>:
                paths[child] = n
                q.append((child, <span class="hljs-built_in">min</span>(flow, cf)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">edmonds_karp</span>(<span class="hljs-params">c, s, t</span>):
    <span class="hljs-string">&quot;&quot;&quot; Compute the flow of the graph with Edmonds-Karp. &quot;&quot;&quot;</span>
    f = {u: {v: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> c} <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> c}
    p = bfs(c, f, s, t)
    flow = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        df, path = p
        u, v = t, path[t]
        flow += df
        <span class="hljs-keyword">while</span> v <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            f[v][u] += df
            f[u][v] = -f[v][u]
            u, v = v, path[v]
        p = bfs(c, f, s, t)
    <span class="hljs-keyword">return</span> flow, f</code></pre>
<p>Problems:</p>
<p>Max Flow</p>
<ul>
<li><p><a href="http://poj.org/problem?id=1273">http://poj.org/problem?id=1273</a> &#40;USACO Drainage Ditches&#41;</p>
</li>
<li><p><a href="https://codeforces.com/problemset/problem/843/E">https://codeforces.com/problemset/problem/843/E</a></p>
</li>
<li><p><a href="https://www.spoj.com/problems/POTHOLE/">https://www.spoj.com/problems/POTHOLE/</a></p>
</li>
<li><p><a href="https://www.spoj.com/problems/FASTFLOW/">https://www.spoj.com/problems/FASTFLOW/</a></p>
</li>
<li><p><a href="https://open.kattis.com/problems/maxflow">https://open.kattis.com/problems/maxflow</a></p>
</li>
</ul>
<p>Dynamic</p>
<ul>
<li><p><a href="https://codeforces.com/problemset/problem/903/G">https://codeforces.com/problemset/problem/903/G</a></p>
</li>
</ul>
<p>Min-cost</p>
<ul>
<li><p><a href="https://open.kattis.com/problems/mincostmaxflow">https://open.kattis.com/problems/mincostmaxflow</a></p>
</li>
</ul>
<p>Extensions</p>
<ul>
<li><p>Self edge: flow is 0 &#40;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> f(u, u) = -f(u, u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>&#41;, therefore capacity is 0</p>
</li>
<li><p>Multiple edges between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (u, v) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>: one edge with the sum of the capacities</p>
</li>
<li><p>Undirected graph: add <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (u, v) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (v, u) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span></p>
</li>
<li><p>Unweighted graph: weight of 1</p>
</li>
<li><p>If vertex <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex"> v </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> has capacity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>: make new vertices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mtext>in</mtext></msub></mrow><annotation encoding="application/x-tex"> v_\text{in} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">in</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mtext>out</mtext></msub></mrow><annotation encoding="application/x-tex"> v_\text{out} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">out</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. All edges going into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex"> v </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> go into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mtext>in</mtext></msub></mrow><annotation encoding="application/x-tex"> v_\text{in}
  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">in</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, going out of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex"> v </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> goes from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mtext>out</mtext></msub></mrow><annotation encoding="application/x-tex"> v_\text{out} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">out</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Add edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mtext>in</mtext></msub><mo separator="true">,</mo><msub><mi>v</mi><mtext>out</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (v_\text{in}, v_\text{out}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">in</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">out</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> with capacity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</p>
</li>
<li><p>Multiple sources/sinks: make supersource connected to each source with infinite capacity and each sink connected to supersink with infinite capacity</p>
</li>
</ul>
<a href="https://en.wikipedia.org/wiki/Push–relabel_maximum_flow_algorithm">https://en.wikipedia.org/wiki/Push–relabel_maximum_flow_algorithm</a>
<h4 id="matching__2"><a href="#matching__2" class="header-anchor">Matching</a></h4>
<p>Problems:</p>
<a href="https://www.spoj.com/problems/MATCHING/">https://www.spoj.com/problems/MATCHING/</a>
<p>Notes:</p>
<ul>
<li><p>Reduce into max flow by assigning each edge a capacity of 1, add source connected to each left vertex and sink connected to each right vertex.</p>
</li>
</ul>
<h2 id="sorting"><a href="#sorting" class="header-anchor">Sorting</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a> - <a href="https://pdfhost.io/v/E8BXkbbdN_mBIT_Advancedpdf.pdf">Verification: MBIT Hen Hackers</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two</span>(<span class="hljs-params">l1: <span class="hljs-built_in">list</span>, l2: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Takes in two sorted lists and returns a sorted list. &quot;&quot;&quot;</span>
    rtn = []
    p1 = p2 = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> p1 &lt; <span class="hljs-built_in">len</span>(l1) <span class="hljs-keyword">and</span> p2 &lt; <span class="hljs-built_in">len</span>(l2):
        <span class="hljs-keyword">if</span> l1[p1] &lt; l2[p2]:
            rtn.append(l1[p1])
            p1 += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            rtn.append(l2[p2])
            p2 += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> rtn + (l1[p1:] <span class="hljs-keyword">if</span> p1 != <span class="hljs-built_in">len</span>(l1) <span class="hljs-keyword">else</span> l2[p2:])

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Sorts a list. &quot;&quot;&quot;</span>
    m = <span class="hljs-built_in">len</span>(l)&gt;&gt;<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> l <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> merge_two(merge_sort(l[:m]), merge_sort(l[m:]))</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Quicksort">Quick Sort</a> - <a href="">Verification</a> - Complexity: expected <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">n1: <span class="hljs-built_in">int</span>, n2: <span class="hljs-built_in">int</span>, n3: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Finds the median of three numbers. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([n1, n2, n3])[<span class="hljs-number">1</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Sorts a list. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> l
    m = median(l[<span class="hljs-number">0</span>], l[<span class="hljs-built_in">len</span>(l)&gt;&gt;<span class="hljs-number">1</span>], l[-<span class="hljs-number">1</span>])
    l1, l2 = [], []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> l:
        (l1 <span class="hljs-keyword">if</span> n &lt; m <span class="hljs-keyword">else</span> \
        (l2 <span class="hljs-keyword">if</span> n &gt; m <span class="hljs-keyword">else</span> (l1 <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l1) &lt; <span class="hljs-built_in">len</span>(l2) <span class="hljs-keyword">else</span> l2))).append(n)
    <span class="hljs-keyword">return</span> quick_sort(l1) + quick_sort(l2)</code></pre>
<p><a href="https://activities.tjhsst.edu/computervision/lectures/kmeans_Handout.pdf#page&#61;38">Order statistics</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Splits the list by a particular value x. &quot;&quot;&quot;</span>
    left, mid, right = [], [], []
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> l:
        (left <span class="hljs-keyword">if</span> v &lt; x <span class="hljs-keyword">else</span> (right <span class="hljs-keyword">if</span> v &gt; x <span class="hljs-keyword">else</span> mid)).append(v)
    <span class="hljs-keyword">return</span> left, mid, right

<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the upper median of l, via a sort. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(l)[<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">2</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns sorted(l)[i] in O(n) with median of medians as a pivot. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) == <span class="hljs-number">1</span>: <span class="hljs-comment"># base case</span>
        <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>]
    medians = [median(l[<span class="hljs-number">5</span>*i: <span class="hljs-number">5</span>*(i + <span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-(-<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">5</span>))]
    left, mid, right = split(l, select(medians, <span class="hljs-built_in">len</span>(medians)//<span class="hljs-number">2</span>))
    k, m = <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(mid)
    <span class="hljs-keyword">if</span> k &lt;= i &lt;= k + m - <span class="hljs-number">1</span>: <span class="hljs-comment"># pivot is the answer</span>
        <span class="hljs-keyword">return</span> mid[<span class="hljs-number">0</span>]
    <span class="hljs-comment"># recur on sublist and get rid of pivot</span>
    <span class="hljs-keyword">return</span> select(left, i) <span class="hljs-keyword">if</span> i &lt; k <span class="hljs-keyword">else</span> select(right, i - k - m)</code></pre>
<h2 id="data_structures"><a href="#data_structures" class="header-anchor">Data Structures</a></h2>
<h3 id="monotonic_query"><a href="#monotonic_query" class="header-anchor">Monotonic Query</a></h3>
<p><a href="">Monotonic Queue</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/220486/problem/A">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:
    <span class="hljs-string">&quot;&quot;&quot; O(1) append O(1) pop O(1) min query. &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, f=<span class="hljs-built_in">min</span></span>):
        self.stk, self.f = [], f

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stk)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;stack(<span class="hljs-subst">{self.stk}</span>)&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, val</span>):
        self.stk.append(
            (val, self.f(val, self.stk[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> val)
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.stk.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stk) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.stk[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;min() arg is an empty sequence&quot;</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MinQueue</span>:
    <span class="hljs-string">&quot;&quot;&quot;
    O(1) append O(1) pop O(1) min

    Implemented via two min-stacks.
    &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, f=<span class="hljs-built_in">min</span></span>):
        self.instk, self.outstk = MinStack(f), MinStack(f)
        self.f = f

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.instk) + <span class="hljs-built_in">len</span>(self.outstk)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-string">&quot;MinQueue&quot;</span>:
        self.i, self.l = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.l == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">raise</span> StopIteration
        l = [self.outstk.stk, self.instk.stk][self.l]
        <span class="hljs-keyword">if</span> self.i == <span class="hljs-built_in">len</span>(l):
            self.l += <span class="hljs-number">1</span>
            self.i = <span class="hljs-number">0</span>
            <span class="hljs-keyword">return</span> self.__next__()
        v = l[<span class="hljs-built_in">len</span>(l) - <span class="hljs-number">1</span> - self.i] <span class="hljs-keyword">if</span> self.l == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> l[self.i]
        self.i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> v[<span class="hljs-number">0</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;queue(<span class="hljs-subst">{[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self]}</span>)&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, val</span>) -&gt; <span class="hljs-literal">None</span>:
        self.instk.append(val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">popleft</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.outstk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.instk) != <span class="hljs-number">0</span>:
                self.outstk.append(self.instk.pop())
        <span class="hljs-keyword">return</span> self.outstk.pop()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appendleft</span>(<span class="hljs-params">self, val</span>) -&gt; <span class="hljs-literal">None</span>:
        self.outstk.append(val)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.instk) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self.outstk) != <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.f(self.instk.<span class="hljs-built_in">min</span>(), self.outstk.<span class="hljs-built_in">min</span>())
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.instk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.outstk.<span class="hljs-built_in">min</span>()
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.outstk) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.instk.<span class="hljs-built_in">min</span>()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;min() arg is an empty sequence&quot;</span>)</code></pre>
<h3 id="range_minimum_query"><a href="#range_minimum_query" class="header-anchor">Range Minimum Query</a></h3>
<p><a href="http://web.stanford.edu/class/cs166/lectures/00/Slides00.pdf">Stanford lecture slides</a></p>
<p><a href="http://web.stanford.edu/class/cs166/lectures/01/Slides01.pdf">Fischer-Heun</a> - <a href="https://www.spoj.com/problems/RMQSQ/">Verification: SPOJ RMQSQ</a> - Complexity: &lt;O&#40;n&#41;, O&#40;1&#41;&gt;</p>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_number</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the Cartesian number for a given list. &quot;&quot;&quot;</span>
    stk = []
    num = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>] &gt; l[i]:
            stk.pop()
            num &lt;&lt;= <span class="hljs-number">1</span>
        stk.append(l[i])
        num &lt;&lt;= <span class="hljs-number">1</span>
        num |= <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> num &lt;&lt; (<span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(l) - msb(num) - <span class="hljs-number">1</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">msb</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the index of the most significant bit of n. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> n.bit_length() - <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sparse_table</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes a sparse table (think 2^n jump pointers) &quot;&quot;&quot;</span>
    n, m = <span class="hljs-built_in">len</span>(l), math.ceil(math.log2(<span class="hljs-built_in">len</span>(l)))
    dp = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i].append(i)

    k = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">if</span> i + k &gt;= n <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(dp[i + k]):
                <span class="hljs-keyword">break</span>
            <span class="hljs-comment"># min with lambdas is REALLY slow</span>
            <span class="hljs-comment"># dp[i].append(min(dp[i][j], dp[i + k][j], key=lambda x: l[x]))</span>
            dp[i].append(
                dp[i][j] <span class="hljs-keyword">if</span> l[dp[i][j]] &lt;= l[dp[i + k][j]] <span class="hljs-keyword">else</span> dp[i + k][j]
            )
        k &lt;&lt;= <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sparse_rmq</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, table: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the index of the minimum element between i and j. &quot;&quot;&quot;</span>
    k = msb(j - i + <span class="hljs-number">1</span>)
    <span class="hljs-comment"># return min(table[i][k], table[j - (1 &lt;&lt; k) + 1][k], key=lambda x: l[x])</span>
    <span class="hljs-keyword">return</span> table[i][k] <span class="hljs-keyword">if</span> l[table[i][k]] &lt; l[table[j - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]] <span class="hljs-keyword">else</span> \
           table[j - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">full_table</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Computes all possible ranges. &quot;&quot;&quot;</span>
    n = <span class="hljs-built_in">len</span>(l)
    dp = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        dp[i].append(i)

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i + j &gt;= n <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(dp[i + <span class="hljs-number">1</span>]):
                <span class="hljs-keyword">break</span>
            <span class="hljs-comment"># dp[i].append(min(dp[i][j], dp[i + 1][j], key=lambda x: l[x]))</span>
            dp[i].append(
                dp[i][j] <span class="hljs-keyword">if</span> l[dp[i][j]] &lt;= l[dp[i + <span class="hljs-number">1</span>][j]] <span class="hljs-keyword">else</span> dp[i + <span class="hljs-number">1</span>][j]
            )

    <span class="hljs-keyword">return</span> dp

<span class="hljs-keyword">def</span> <span class="hljs-title function_">full_rmq</span>(<span class="hljs-params">table: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; O(1) RMQ. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> table[i][j - i]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fischer_heun</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Constructs the structure in O(n). &quot;&quot;&quot;</span>
    b = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">int</span>(math.log2(<span class="hljs-built_in">len</span>(l))) &gt;&gt; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># k = 1, not k = 1/2 (&gt;&gt; 2 for 1/2)</span>
    blocks = [l[i: i + b] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(l), b)]
    a = [<span class="hljs-built_in">min</span>(block) <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]
    indexes = [<span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">min</span>(i + b, <span class="hljs-built_in">len</span>(l))), key=<span class="hljs-keyword">lambda</span> x: l[x])
               <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(l), b)]
    table = sparse_table(a)
    ids = [cartesian_number(block) <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks]

    tables = {}
    <span class="hljs-keyword">for</span> i, block <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(blocks):
        <span class="hljs-keyword">if</span> ids[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> tables:
            tables[ids[i]] = full_table(block)

    <span class="hljs-keyword">return</span> b, a, indexes, ids, table, tables

<span class="hljs-keyword">def</span> <span class="hljs-title function_">rmq</span>(<span class="hljs-params">o: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span>, indexes: <span class="hljs-built_in">list</span>, ids: <span class="hljs-built_in">list</span>,
        table: <span class="hljs-built_in">list</span>, tables: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot; O(1) RMQ. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> i &gt; j:
        i, j = j, i
    l, r = i//b, j//b         <span class="hljs-comment"># block indexes</span>
    li, ri = i - l*b, j - r*b <span class="hljs-comment"># index in the block</span>
    <span class="hljs-comment"># in same block</span>
    <span class="hljs-keyword">if</span> l == r:
        <span class="hljs-keyword">return</span> b*l + full_rmq(tables[ids[l]], li, ri)
    i1 = b*l + full_rmq(tables[ids[l]], li, b - <span class="hljs-number">1</span>)
    i2 = indexes[sparse_rmq(a, table, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>)] <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= l + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
    i3 = b*r + full_rmq(tables[ids[r]], <span class="hljs-number">0</span>, ri)

    v = i1 <span class="hljs-keyword">if</span> o[i1] &lt; o[i3] <span class="hljs-keyword">else</span> i3
    <span class="hljs-keyword">return</span> v <span class="hljs-keyword">if</span> i2 == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> o[v] &lt; o[i2] <span class="hljs-keyword">else</span> i2</code></pre>
<h3 id="trees"><a href="#trees" class="header-anchor">Trees</a></h3>
<h4 id="binary_indexed_trees_bits"><a href="#binary_indexed_trees_bits" class="header-anchor">Binary Indexed Trees &#40;BITS&#41;</a></h4>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_01_Binary_Index_Trees.pdf">Binary Indexed Trees</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> construction, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> query</p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            self.l = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(n) + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n)):
                self.update(i, n[i])
        <span class="hljs-keyword">else</span>:
            self.l = [<span class="hljs-number">0</span>]*(n + <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.l)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-string">&quot;&quot;&quot; sum of elements up to (and including) i &quot;&quot;&quot;</span>
        i += <span class="hljs-number">1</span>
        ans = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span>:
            ans += self.l[i]
            i -= (i &amp; -i)
        <span class="hljs-keyword">return</span> ans

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">range</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-string">&quot;&quot;&quot; sum of elements between i and j, inclusive on both ends &quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> self.query(j) - (self.query(i - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.l):
            self.l[i] += v
            i += (i &amp; -i)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RBIT</span>:

    <span class="hljs-string">&quot;&quot;&quot; BITs with range update. &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        p = <span class="hljs-built_in">len</span>(n) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">else</span> n
        self.t1, self.t2 = BIT(p), BIT(p)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):
                self.update(i, i, n[i])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">{self.t1}</span> <span class="hljs-subst">{self.t2}</span>&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> i*self.t1.query(i) + self.t2.query(i)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">range</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> self.query(j) - (self.query(i - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.t1.update(i, v)
        self.t1.update(j + <span class="hljs-number">1</span>, -v)
        self.t2.update(i, -(i - <span class="hljs-number">1</span>)*v)
        self.t2.update(j + <span class="hljs-number">1</span>, j*v)</code></pre>
<h4 id="segment_tree"><a href="#segment_tree" class="header-anchor">Segment Tree</a></h4>
<p><a href="https://activities.tjhsst.edu/sct/lectures/1920/2019_11_15_Segment_Trees.pdf">Segment Tree</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> construction, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> query</p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">list</span>):
            self.l = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(n)&lt;&lt;<span class="hljs-number">2</span>)
            self.build(n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(n) - <span class="hljs-number">1</span>)
            self.n = <span class="hljs-built_in">len</span>(n)
        <span class="hljs-keyword">else</span>:
            self.l = [<span class="hljs-number">0</span>]*(n&lt;&lt;<span class="hljs-number">2</span>)
            self.n = n
        self.lazy = [<span class="hljs-number">0</span>]*(self.n&lt;&lt;<span class="hljs-number">2</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.l)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">list</span>, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># leaf</span>
        <span class="hljs-keyword">if</span> l == r:
            self.l[p] = a[l]
        <span class="hljs-keyword">else</span>:
            pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
            m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
            self.build(a, pl, l, m)
            self.build(a, pr, m + <span class="hljs-number">1</span>, r)
            self.l[p] = self.l[pl] + self.l[pr]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>):
        <span class="hljs-string">&quot;&quot;&quot; Propagate lazy values &quot;&quot;&quot;</span>
        pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
        <span class="hljs-comment"># update the actual value proportional</span>
        <span class="hljs-comment"># to the number of elements in the range</span>
        self.l[p] += (r - l + <span class="hljs-number">1</span>)*self.lazy[p]
        <span class="hljs-comment"># not leaf</span>
        <span class="hljs-keyword">if</span> l != r:
            self.lazy[pl] += self.lazy[p]
            self.lazy[pr] += self.lazy[p]
        self.lazy[p] = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> self.subquery(i, j, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, self.n - <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subquery</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-comment"># segment outside query</span>
        <span class="hljs-keyword">if</span> i &gt; r <span class="hljs-keyword">or</span> j &lt; l:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        self.push(p, l, r)
        <span class="hljs-comment"># segment inside query</span>
        <span class="hljs-keyword">if</span> i &lt;= l <span class="hljs-keyword">and</span> r &lt;= j:
            <span class="hljs-keyword">return</span> self.l[p]
        <span class="hljs-comment"># partial</span>
        pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
        m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
        vl = self.subquery(i, j, pl, l, m)
        vr = self.subquery(i, j, pr, m + <span class="hljs-number">1</span>, r)
        <span class="hljs-keyword">return</span> (vl + vr)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.subupdate(i, j, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, self.n - <span class="hljs-number">1</span>, v)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subupdate</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>,
                  l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> i &gt; r <span class="hljs-keyword">or</span> j &lt; l:
            <span class="hljs-keyword">return</span>
        self.push(p, l, r)
        <span class="hljs-keyword">if</span> i &lt;= l <span class="hljs-keyword">and</span> r &lt;= j:
            self.lazy[p] += v
            self.push(p, l, r)
        <span class="hljs-keyword">else</span>:
            pl, pr = p&lt;&lt;<span class="hljs-number">1</span>, p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>
            m = (l + r)&gt;&gt;<span class="hljs-number">1</span>
            self.subupdate(i, j, pl, l, m, v)
            self.subupdate(i, j, pr, m + <span class="hljs-number">1</span>, r, v)
            self.l[p] = self.l[pl] + self.l[pr]</code></pre>
<h4 id="avl_tree"><a href="#avl_tree" class="header-anchor">AVL Tree</a></h4>
<p><a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a> - <a href="">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> construction, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(\log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> query</p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span>, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):
        self.key = key
        self.value = value
        self.parent = parent
        self.child = [left, right]
        self.balance = <span class="hljs-number">0</span>
        self.height = <span class="hljs-number">1</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">{self.key}</span>:<span class="hljs-subst">{self.value}</span>:<span class="hljs-subst">{self.balance}</span>&quot;</span> \
            <span class="hljs-keyword">if</span> self.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">str</span>(self.key)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extrema</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>):
        n = self
        <span class="hljs-keyword">while</span> n.child[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            n = n.child[i]
        <span class="hljs-keyword">return</span> n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.extrema(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.extrema(<span class="hljs-number">1</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.root = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">&quot;&quot;</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self.root
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> s
        s = self.__str__(n.child[<span class="hljs-number">0</span>], s, d + <span class="hljs-number">1</span>)
        s += <span class="hljs-string">&quot; &quot;</span>*<span class="hljs-number">4</span>*d + <span class="hljs-built_in">str</span>(n) + <span class="hljs-string">&quot;\n&quot;</span>
        s = self.__str__(n.child[<span class="hljs-number">1</span>], s, d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> s

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-comment"># future: OS tree (302 in introduction to algorithms)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> self.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.root.<span class="hljs-built_in">min</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> self.root.<span class="hljs-built_in">max</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">if</span> self.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.root = Node(key, value)
            <span class="hljs-keyword">return</span>
        self.subadd(key, value, self.root)

        n = self.find(key, value)
        self.trace_heights(n)
        self.trace(n)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">return</span> self.subfind(key, value, self.root)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">contains</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> self.find(key, value) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, key, value=<span class="hljs-literal">None</span></span>):
        n = self.find(key, value)
        <span class="hljs-comment"># leaf node</span>
        <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-comment"># root node</span>
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, <span class="hljs-literal">None</span>)
            to_trace = n.parent
        <span class="hljs-keyword">elif</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = n.child[<span class="hljs-number">1</span>]
                self.root.parent = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, n.child[<span class="hljs-number">1</span>])
            to_trace = n.child[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">elif</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">if</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.root = n.child[<span class="hljs-number">0</span>]
                self.root.parent = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">return</span>
            self.set_children(n.parent, n.key, n.child[<span class="hljs-number">0</span>])
            to_trace = n.child[<span class="hljs-number">0</span>]
        <span class="hljs-comment"># two children</span>
        <span class="hljs-keyword">else</span>:
            temp = n.child[<span class="hljs-number">0</span>].<span class="hljs-built_in">max</span>()
            n.key, n.value = temp.key, temp.value
            self.set_children(temp.parent, temp.key, temp.child[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">if</span> temp.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                self.trace_heights(temp.child[<span class="hljs-number">0</span>])
            self.trace_heights(temp)
            <span class="hljs-keyword">return</span>

        self.trace_heights(to_trace)
        self.trace(to_trace)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, key, value, new</span>):
        self.delete(key, value)
        self.add(new, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        n = self.<span class="hljs-built_in">min</span>()
        self.delete(n.key, n.value)
        <span class="hljs-keyword">return</span> n.key, n.value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_children</span>(<span class="hljs-params">self, n, key, value</span>):
        n.child[key &gt; n.key] = value
        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            value.parent = n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subadd</span>(<span class="hljs-params">self, key, value, n</span>):
        <span class="hljs-keyword">if</span> n.child[key &gt; n.key] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            n.child[key &gt; n.key] = Node(key, value, n)
            <span class="hljs-keyword">return</span>
        self.subadd(key, value, n.child[key &gt; n.key])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subfind</span>(<span class="hljs-params">self, key, value, n</span>):
        <span class="hljs-keyword">if</span> key == n.key <span class="hljs-keyword">and</span> value == n.value:
            <span class="hljs-keyword">return</span> n

        <span class="hljs-keyword">if</span> n.child[key &gt; n.key] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        <span class="hljs-keyword">return</span> self.subfind(key, value, n.child[key &gt; n.key])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trace_heights</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-keyword">while</span> n <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.update_height(n)
            n = n.parent

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_height</span>(<span class="hljs-params">self, n</span>):
        left  = n.child[<span class="hljs-number">0</span>].height <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        right = n.child[<span class="hljs-number">1</span>].height <span class="hljs-keyword">if</span> n.child[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        n.height = <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>
        n.balance = right - left

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-keyword">while</span> n.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            p = n.parent
            <span class="hljs-comment"># right child</span>
            <span class="hljs-keyword">if</span> n.key &gt; p.key:
                <span class="hljs-keyword">if</span> p.balance == <span class="hljs-number">2</span>:
                    (self.rotate_right_left <span class="hljs-keyword">if</span> n.balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
                     self.rotate_left)(p, n)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> p.balance == -<span class="hljs-number">2</span>:
                    (self.rotate_left_right <span class="hljs-keyword">if</span> n.balance &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> \
                     self.rotate_right)(p, n)
            n = p

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, p, n, d</span>):
        c = n.child[d]
        p.child[d ^ <span class="hljs-number">1</span>] = c

        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            c.parent = p
        n.child[d] = p

        n.parent = p.parent
        <span class="hljs-keyword">if</span> p.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            p.parent.child[p.key &gt; p.parent.key] = n
        <span class="hljs-keyword">else</span>:
            self.root = n
        p.parent = n

        <span class="hljs-comment"># order matters: update from the bottom up</span>
        self.update_height(p)
        self.update_height(n)

        <span class="hljs-keyword">return</span> n

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_left</span>(<span class="hljs-params">self, p, n</span>): <span class="hljs-keyword">return</span> self.rotate(p, n, <span class="hljs-number">0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_right</span>(<span class="hljs-params">self, p, n</span>): <span class="hljs-keyword">return</span> self.rotate(p, n, <span class="hljs-number">1</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_left_right</span>(<span class="hljs-params">self, p, n</span>):
        <span class="hljs-keyword">return</span> self.rotate_right(p, self.rotate_left(n, n.child[<span class="hljs-number">1</span>]))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_right_left</span>(<span class="hljs-params">self, p, n</span>):
        <span class="hljs-keyword">return</span> self.rotate_left(p, self.rotate_right(n, n.child[<span class="hljs-number">0</span>]))</code></pre>
<h4 id="cartesian_tree"><a href="#cartesian_tree" class="header-anchor">Cartesian Tree</a></h4>
<p><a href="http://web.stanford.edu/class/cs166/lectures/01/Slides01.pdf">Cartesian Tree</a> - <a href="https://www.spoj.com/problems/RMQSQ/">Verification: SPOJ RMQSQ</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CartesianTree</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, parent=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):
        self.key = key
        self.parent = parent
        self.child = [left, right]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n=<span class="hljs-literal">None</span>, s=<span class="hljs-string">&quot;&quot;</span>, d=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> s
        s = self.__str__(n.child[<span class="hljs-number">0</span>], s, d + <span class="hljs-number">1</span>)
        s += <span class="hljs-string">&quot; &quot;</span>*<span class="hljs-number">4</span>*d + <span class="hljs-built_in">str</span>(n.key) + <span class="hljs-string">&quot;\n&quot;</span>
        s = self.__str__(n.child[<span class="hljs-number">1</span>], s, d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> s

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cartesian_tree</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; CartesianTree:
    <span class="hljs-string">&quot;&quot;&quot; Constructs a Cartesian tree for a given list in O(n). &quot;&quot;&quot;</span>
    stk = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):
        c = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> stk[-<span class="hljs-number">1</span>].key &gt; l[i]:
            c = stk.pop()
        stk.append(CartesianTree(l[i], stk[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, c))
        <span class="hljs-comment"># add right child</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) &gt; <span class="hljs-number">1</span>:
            stk[-<span class="hljs-number">2</span>].child[<span class="hljs-number">1</span>] = stk[-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">return</span> stk[<span class="hljs-number">0</span>]</code></pre>
<h4 id="kd-tree"><a href="#kd-tree" class="header-anchor">kd-Tree</a></h4>
<p><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf">CMU lecture slides</a></p>
<p><a href="https://activities.tjhsst.edu/computervision/lectures/kmeans_Handout.pdf">kd-Tree</a> - <a href="">Verification</a> - Complexity:</p>
<ul>
<li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> construction</p>
</li>
<li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>d</mi></msup><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(2^d + \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> nearest neighbor query</p>
</li>
</ul>
<pre><code class="python hljs"><span class="hljs-comment">### median selection</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select_split</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Splits the list by a particular value x. &quot;&quot;&quot;</span>
    left, mid, right = [], [], []
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> l:
        (left <span class="hljs-keyword">if</span> v &lt; x <span class="hljs-keyword">else</span> (right <span class="hljs-keyword">if</span> v &gt; x <span class="hljs-keyword">else</span> mid)).append(v)
    <span class="hljs-keyword">return</span> left, mid, right

<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the upper median of l, via a sort. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(l)[<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">2</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">l: <span class="hljs-built_in">list</span>, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns sorted(l)[i] in O(n) with median of medians as a pivot. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) == <span class="hljs-number">1</span>: <span class="hljs-comment"># base case</span>
        <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>]
    medians = [median(l[<span class="hljs-number">5</span>*i: <span class="hljs-number">5</span>*(i + <span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-(-<span class="hljs-built_in">len</span>(l)//<span class="hljs-number">5</span>))]
    left, mid, right = select_split(l, select(medians, <span class="hljs-built_in">len</span>(medians)//<span class="hljs-number">2</span>))
    k, m = <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(mid)
    <span class="hljs-keyword">if</span> k &lt;= i &lt;= k + m - <span class="hljs-number">1</span>: <span class="hljs-comment"># pivot is the answer</span>
        <span class="hljs-keyword">return</span> mid[<span class="hljs-number">0</span>]
    <span class="hljs-comment"># recur on sublist and get rid of pivot</span>
    <span class="hljs-keyword">return</span> select(left, i) <span class="hljs-keyword">if</span> i &lt; k <span class="hljs-keyword">else</span> select(right, i - k - m)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">split_median</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Picks the point which is the median along the dimension cd. &quot;&quot;&quot;</span>
    m = select([point[cd] <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points], <span class="hljs-built_in">len</span>(points)//<span class="hljs-number">2</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):
        <span class="hljs-keyword">if</span> points[i][cd] == m: <span class="hljs-comment"># pick any point with value m</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> points[i], points[:i] + points[i + <span class="hljs-number">1</span>:]

<span class="hljs-comment">### helper methods</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Squared distance between two points.&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>((p1[i] - p2[i])*(p1[i] - p2[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p1)))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">closest</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, q: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Returns the point closest to q in points (nearest neighbor query). &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(points, key=<span class="hljs-keyword">lambda</span> p: dist(p, q))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">distbb</span>(<span class="hljs-params">p: <span class="hljs-built_in">tuple</span>, bb: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Squared distance between a point and a bounding box. &quot;&quot;&quot;</span>
    <span class="hljs-comment"># three cases, use x if x is in the box, otherwise one of the bounds</span>
    bbp = <span class="hljs-built_in">tuple</span>(box[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> x &lt; box[<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> (box[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> x &gt; box[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> x)
                <span class="hljs-keyword">for</span> x, box <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(p, bb))
    <span class="hljs-keyword">return</span> dist(p, bbp)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">trimbb</span>(<span class="hljs-params">bb: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Trims the bounding box by the plane x_cd = p[cd]. &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bb) == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> bb
    bb = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">list</span>(box) <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> bb) <span class="hljs-comment"># copy</span>
    bb[cd][<span class="hljs-number">1</span> - d] = p[cd]              <span class="hljs-comment"># update, assuming p[cd] is valid</span>
    <span class="hljs-keyword">return</span> bb

<span class="hljs-comment">### kd-tree</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-string">&quot;&quot;&quot; Splits the list of points by the plane x_cd = p[cd]. &quot;&quot;&quot;</span>
    left, right = [], []
    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:
        <span class="hljs-comment"># add point with the same value as p at cd to the right side</span>
        (left <span class="hljs-keyword">if</span> point[cd] &lt; p[cd] <span class="hljs-keyword">else</span> right).append(point)
    <span class="hljs-keyword">return</span> left, right

<span class="hljs-keyword">class</span> <span class="hljs-title class_">kdNode</span>:

    <span class="hljs-string">&quot;&quot;&quot; kd-tree node. &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, point: <span class="hljs-built_in">tuple</span>=<span class="hljs-literal">None</span>, cd: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-literal">None</span>:
        self.child, self.point, self.cd, self.bb = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>], point, cd, []
        self.D, self.tight_bb = <span class="hljs-built_in">len</span>(point) <span class="hljs-keyword">if</span> point <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self, n: <span class="hljs-string">&quot;kdNode&quot;</span>=<span class="hljs-literal">None</span>, d: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">&quot;&quot;&quot; Fancy string representation. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>: n = self <span class="hljs-comment"># called with None by defualt, set to the root</span>
        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> [] <span class="hljs-comment"># leaf node</span>
        s = [<span class="hljs-string">f&quot;<span class="hljs-subst">{<span class="hljs-string">&#x27; &#x27;</span>*<span class="hljs-number">4</span>*d}</span><span class="hljs-subst">{n.point}</span>&quot;</span>]
        s += self.__str__(n.child[<span class="hljs-number">0</span>], d + <span class="hljs-number">1</span>)
        s += self.__str__(n.child[<span class="hljs-number">1</span>], d + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(s) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> s

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dir</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">&quot;&quot;&quot; Gets the proper left/right child depending on the point. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> p[self.cd] &gt;= self.point[self.cd]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tighten</span>(<span class="hljs-params">self, t: <span class="hljs-string">&quot;KdNode&quot;</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">&quot;&quot;&quot; Tighten bounding boxes in O(nd). &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: t = self <span class="hljs-comment"># called with None, set to the root</span>
        l, r, t.tight_bb = t.child[<span class="hljs-number">0</span>], t.child[<span class="hljs-number">1</span>], <span class="hljs-literal">True</span>
        <span class="hljs-comment"># recur on children</span>
        <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: self.tighten(l)
        <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: self.tighten(r)
        <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># leaf node, box is just the singular point</span>
            t.bb = [(t.point[d], t.point[d]) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t.D)]
        <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># one child, inherit box of child</span>
            t.bb = l.bb <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> r.bb
            t.bb = [(<span class="hljs-built_in">min</span>(box[<span class="hljs-number">0</span>], v), <span class="hljs-built_in">max</span>(box[<span class="hljs-number">1</span>], v))  <span class="hljs-comment"># add node&#x27;s point</span>
                    <span class="hljs-keyword">for</span> box, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(t.bb, t.point)]
        <span class="hljs-keyword">else</span>:                        <span class="hljs-comment"># two children, combine boxes</span>
            t.bb = [(<span class="hljs-built_in">min</span>(bbl[<span class="hljs-number">0</span>], bbr[<span class="hljs-number">0</span>], v), <span class="hljs-built_in">max</span>(bbl[<span class="hljs-number">1</span>], bbr[<span class="hljs-number">1</span>], v))
                    <span class="hljs-keyword">for</span> bbl, bbr, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(l.bb, r.bb, t.point)]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add</span>(<span class="hljs-params">self, t: <span class="hljs-string">&quot;kdNode&quot;</span>, p: <span class="hljs-built_in">tuple</span>, parent: <span class="hljs-string">&quot;kdNode&quot;</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">&quot;&quot;&quot; Insert the given point into the tree. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:      <span class="hljs-comment"># found leaf to insert new node in</span>
            t = kdNode(p, (parent.cd + <span class="hljs-number">1</span>) % parent.D)
        <span class="hljs-keyword">elif</span> t.point == p: <span class="hljs-comment"># ignore duplicates</span>
            <span class="hljs-keyword">return</span> t
        <span class="hljs-keyword">else</span>:              <span class="hljs-comment"># update pointers</span>
            t.child[t.<span class="hljs-built_in">dir</span>(p)] = self.__add(t.child[t.<span class="hljs-built_in">dir</span>(p)], p, t)
            t.tight_bb = <span class="hljs-literal">False</span> <span class="hljs-comment"># no longer use tight bounding boxes</span>
            <span class="hljs-comment"># is it worth O(d log n) instead of O(log n) for tighter boxes?</span>
            <span class="hljs-comment"># if so, manually update t.bb over each of the d dimensions</span>
        <span class="hljs-keyword">return</span> t

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">&quot;&quot;&quot; Wrapper over the recursive helper function __add. &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> self.point <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># empty tree, simply change our own point</span>
            self.__init__(p)
        self.__add(self, p)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__closest</span>(<span class="hljs-params">self, t: <span class="hljs-string">&quot;kdNode&quot;</span>, p: <span class="hljs-built_in">tuple</span>, curr_bb: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">&quot;&quot;&quot; Returns the closest point to p in the tree (nearest neighbor). &quot;&quot;&quot;</span>
        <span class="hljs-comment"># all points in this bounding box farther than existing point</span>
        bb = t.bb <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> t.tight_bb <span class="hljs-keyword">else</span> curr_bb
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> distbb(p, bb) &gt; self.best_dist:
            <span class="hljs-keyword">return</span>
        <span class="hljs-comment"># update best point</span>
        d = dist(p, t.point)
        <span class="hljs-keyword">if</span> d &lt; self.best_dist:
            self.best, self.best_dist = t.point, d
        <span class="hljs-comment"># visit subtrees in order of distance from p</span>
        i, j = t.<span class="hljs-built_in">dir</span>(p), <span class="hljs-number">1</span> - t.<span class="hljs-built_in">dir</span>(p)
        self.__closest(t.child[i], p, trimbb(curr_bb, t.cd, t.point, i))
        self.__closest(t.child[j], p, trimbb(curr_bb, t.cd, t.point, j))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closest</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">&quot;&quot;&quot; Wrapper over the recursive helper function __closest. &quot;&quot;&quot;</span>
        self.best, self.best_dist = <span class="hljs-literal">None</span>, <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)
        bb = [[-<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p))]
        self.__closest(self, p, [] <span class="hljs-keyword">if</span> self.tight_bb <span class="hljs-keyword">else</span> bb)
        <span class="hljs-keyword">return</span> self.best

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nnsearch</span>(<span class="hljs-params">self, p: <span class="hljs-built_in">tuple</span>, r: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
        <span class="hljs-string">&quot;&quot;&quot; Finds the points that are within a radius of r from p. &quot;&quot;&quot;</span>
        l = []
        h = [(<span class="hljs-number">0</span>, self)]
        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(h) &gt; <span class="hljs-number">0</span>:
            d, n = heapq.heappop(h)
            <span class="hljs-keyword">if</span> d &gt; r*r: <span class="hljs-comment"># stop processing if out of circle</span>
                <span class="hljs-keyword">return</span> l
            <span class="hljs-keyword">if</span> is_leaf(n):
                l.append(n.point)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> n.child + [kdNode(n.point)]:
                    <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                        d = dist(p, child.point) <span class="hljs-keyword">if</span> is_leaf(child) <span class="hljs-keyword">else</span> \
                            distbb(p, child.bb)
                        heapq.heappush(h, (d, child))
        <span class="hljs-keyword">return</span> l

<span class="hljs-keyword">class</span> <span class="hljs-title class_">kdTree</span>(<span class="hljs-title class_ inherited__">kdNode</span>):

    <span class="hljs-string">&quot;&quot;&quot; Thin wrapper over a kd-node to build a tree from a list of points.  &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, points: <span class="hljs-built_in">list</span>=[]</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-comment"># no need for duplicate points</span>
            self.__build_tree(self, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(points)))
            self.tighten()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__build_tree</span>(<span class="hljs-params">self, t: kdNode, points: <span class="hljs-built_in">list</span>, cd: <span class="hljs-built_in">int</span>=<span class="hljs-number">0</span></span>) -&gt; kdNode:
        <span class="hljs-string">&quot;&quot;&quot; Constructs a kd-tree in O(n log n). &quot;&quot;&quot;</span>
        N, D, t.cd = <span class="hljs-built_in">len</span>(points), <span class="hljs-built_in">len</span>(points[<span class="hljs-number">0</span>]), cd
        t.point, points = split_median(points, cd) <span class="hljs-comment"># median</span>
        t.D, next_cd = D, (cd + <span class="hljs-number">1</span>) % D
        t.child = [self.__build_tree(kdNode(), l, next_cd) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) &gt; <span class="hljs-number">0</span>
                   <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> split(points, cd, t.point)]
        <span class="hljs-keyword">return</span> t</code></pre>
<h3 id="prefix_sums"><a href="#prefix_sums" class="header-anchor">Prefix Sums</a></h3>
<p><a href="">1D Prefix Sums</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/259141/problem/C">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">i, j</span>):
    <span class="hljs-keyword">return</span> prefix[j + <span class="hljs-number">1</span>] - prefix[i]

prefix = [<span class="hljs-number">0</span>]*(N + <span class="hljs-number">1</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):
    prefix[i + <span class="hljs-number">1</span>] = prefix[i] + a[i]</code></pre>
<p><a href="">2D Prefix Sums</a> - <a href="https://codeforces.com/group/M4wsRWBHyZ/contest/232015/problem/D">Verification</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(nm) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">prefix, x1, y1, x2, y2</span>):
    <span class="hljs-keyword">return</span> prefix[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] - prefix[x2 + <span class="hljs-number">1</span>][y1] - prefix[x1][y2 + <span class="hljs-number">1</span>] + \
           prefix[x1][y1]

prefix = [[<span class="hljs-number">0</span>]*(M + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N + <span class="hljs-number">1</span>)]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix[<span class="hljs-number">0</span>])):
        prefix[i][j] = prefix[i - <span class="hljs-number">1</span>][j] + m[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prefix)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prefix[<span class="hljs-number">0</span>])):
        prefix[i][j] = prefix[i][j - <span class="hljs-number">1</span>]</code></pre>
<h2 id="computational_geometry"><a href="#computational_geometry" class="header-anchor">Computational Geometry</a></h2>
<p>Helper methods</p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">float</span>:
    <span class="hljs-string">&quot;&quot;&quot; Squared l2 distance between the points p1 and p2. &quot;&quot;&quot;</span>
    (x1, y1), (x2, y2) = p1, p2
    <span class="hljs-keyword">return</span> ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ccw</span>(<span class="hljs-params">p1: <span class="hljs-built_in">tuple</span>, p2: <span class="hljs-built_in">tuple</span>, p3: <span class="hljs-built_in">tuple</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">&quot;&quot;&quot; Whether (p1, p2, p3) forms a counterclockwise turn.
    &gt; 0 counterclockwise, = 0 collinear, and &lt; 0 clockwise. &quot;&quot;&quot;</span>
    (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3
    <span class="hljs-comment"># this is reasonably numerically stable, no need to check &gt; EPS</span>
    <span class="hljs-keyword">return</span> (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)</code></pre>
<h3 id="closest_pair"><a href="#closest_pair" class="header-anchor">Closest Pair</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Closest_pair_of_points_problem">Closest pair</a> - <a href="">Verification: CV</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">slow_closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    best = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):
            <span class="hljs-keyword">if</span> dist(points[i], points[j]) &lt; best:
                best, p1, p2 = dist(points[i], points[j]), points[i], points[j]
    <span class="hljs-keyword">return</span> p1, p2

<span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, x: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">return</span> [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>] &lt;= x], [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>] &gt; x]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recur_closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span>, X: <span class="hljs-built_in">list</span>, Y: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &lt;= <span class="hljs-number">3</span>:
        <span class="hljs-keyword">return</span> slow_closest_pair(points)

    mid = <span class="hljs-built_in">len</span>(X)//<span class="hljs-number">2</span>
    x = (X[mid][<span class="hljs-number">0</span>] + X[mid - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(X) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> X[mid][<span class="hljs-number">0</span>]
    pointsl, pointsr = divide(points, x)
    Xl, Xr = divide(X, x)
    Yl, Yr = divide(Y, x)

    l1, l2 = recur_closest_pair(pointsl, Xl, Yl)
    r1, r2 = recur_closest_pair(pointsr, Xr, Yr)

    dl, dr = dist(l1, l2), dist(*r1, *r2)
    d = <span class="hljs-built_in">min</span>(dl, dr)

    dp = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)
    Yp = [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> Y <span class="hljs-keyword">if</span> x - d &lt;= p[<span class="hljs-number">0</span>] &lt;= x + d]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Yp)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(i + <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(Yp))):
            <span class="hljs-keyword">if</span> dist(Yp[i], Yp[j]) &lt; dp:
                dp, m1, m2 = dist(Yp[i], Yp[j]), Yp[i],  Yp[j]

    <span class="hljs-keyword">if</span> dp &lt; d:
        <span class="hljs-keyword">return</span> m1, m2
    <span class="hljs-keyword">return</span> (l1, l2) <span class="hljs-keyword">if</span> dl &lt; dr <span class="hljs-keyword">else</span> (r1, r2)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">closest_pair</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:
    <span class="hljs-keyword">return</span> recur_closest_pair(points,
                              <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> p: p[<span class="hljs-number">0</span>]),
                              <span class="hljs-built_in">sorted</span>(points, key=<span class="hljs-keyword">lambda</span> p: p[<span class="hljs-number">1</span>]))</code></pre>
<h3 id="convex_hull"><a href="#convex_hull" class="header-anchor">Convex Hull</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Graham_scan">Graham scan</a>, specifically <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Andrew&#39;s Monotone Chain</a> - <a href="https://open.kattis.com/problems/convexhull">Verification: Kattis convexhull</a> - Complexity: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathcal{O}(n \log n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convex_hull</span>(<span class="hljs-params">points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:
    <span class="hljs-string">&quot;&quot;&quot; Finds the convex hull of the point list. &quot;&quot;&quot;</span>
    points = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(points))
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> points

    final = []
    <span class="hljs-keyword">for</span> half <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):
        hull = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ccw(hull[-<span class="hljs-number">2</span>], hull[-<span class="hljs-number">1</span>], p) &lt;= <span class="hljs-number">0</span>:
                hull.pop()
            hull.append(p)
        final += hull[:-<span class="hljs-number">1</span>]
        points = points[::-<span class="hljs-number">1</span>]

    <span class="hljs-keyword">return</span> final</code></pre>
<h2 id="ad-hoc"><a href="#ad-hoc" class="header-anchor">Ad-hoc</a></h2>
<h3 id="grid_bfs_problems"><a href="#grid_bfs_problems" class="header-anchor">Grid BFS Problems</a></h3>
<pre><code class="python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc</span>(<span class="hljs-params">i</span>): <span class="hljs-keyword">return</span> i//N, i % N

<span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid</span>(<span class="hljs-params">i, j</span>): <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= i &lt; M <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; N

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_children</span>(<span class="hljs-params">i, j</span>):
    <span class="hljs-keyword">return</span> [child <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> [(i + <span class="hljs-number">1</span>, j), (i - <span class="hljs-number">1</span>, j), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>)]
            <span class="hljs-keyword">if</span> is_valid(*child)]</code></pre>
<div class="page-foot">
  さみしいも、たのしい。<a href="https://github.com/stephen-huan/stephen-huan.github.io/blob/master/blog/algorithm-library.md">Page source</a>. Last updated: <time datetime="2022-12-26">2022-12-26</time>.
  <!-- Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. -->
</div>
</div><!-- CONTENT ENDS HERE -->
  </body>
</html>
